## Safe Confluence XAU Bot - Professional Edition v17
## ULTRA ENHANCED with Gold-Specific Optimizations
## TEST ON DEMO ACCOUNT FIRST.

import MetaTrader5 as mt5
import pandas as pd
import numpy as np
import time
import math
import threading
import logging
import csv
import os
import json
import hashlib
from datetime import datetime, date, time as dt_time, timedelta
from typing import Dict, List, Tuple, Optional, Any
from collections import deque, defaultdict
from dataclasses import dataclass, field
from ta.trend import EMAIndicator, MACD
from ta.volatility import AverageTrueRange
from ta.momentum import RSIIndicator, StochasticOscillator

# ==================== SECURITY & CONFIGURATION ====================
import os
from dotenv import load_dotenv
load_dotenv()

@dataclass
class BotConfig:
    # MT5 Connection
    LOGIN: int = int(os.getenv("MT5_LOGIN", "52536980"))
    PASSWORD: str = os.getenv("MT5_PASSWORD", "z!Kt1zsRa8Buyb")
    SERVER: str = os.getenv("MT5_SERVER", "ICMarketsSC-Demo")
    
    # Trading Parameters
    SYMBOLS: List[str] = field(default_factory=lambda: ["XAUUSD", "XAUJPY"])
    ENTRY_TF: int = mt5.TIMEFRAME_M5
    HTF_TF: int = mt5.TIMEFRAME_M15
    MAGIC: int = 987654
    MODE: str = "GOLD_CONFLUENCE"
    
    # Risk Management - GOLD OPTIMIZED
    LOT_FIXED: float = 0.01
    USE_FIXED_LOT: bool = True
    MAX_TRADES_PER_SYMBOL: int = 2
    MAX_POSITIONS_TOTAL: int = 4
    COOLDOWN: int = 300  # Reduced to 5 minutes for faster recovery
    FORCE_TRADE_EVERY: int = 600  # 10 minutes for gold
    
    # Indicator Parameters
    EMA_FAST: int = 5
    EMA_SLOW: int = 13
    ATR_PERIOD: int = 14
    RSI_PERIOD: int = 7
    RSI_OB: int = 70
    RSI_OS: int = 30
    MIN_ATR: float = 0.15  # Increased for gold
    SL_ATR_MULT: float = 2.0  # Wider stops for gold
    TP_ATR_MULT: float = 3.5  # Better risk/reward for gold
    
    # Gold-Specific Parameters
    GOLD_MIN_ATR: float = 0.15
    GOLD_SL_MULTIPLIER: float = 2.0
    GOLD_TP_MULTIPLIER: float = 3.5
    
    # Session Settings
    TRADE_ASIAN_SESSION: bool = False
    TRADE_LONDON_SESSION: bool = True
    TRADE_NY_SESSION: bool = True
    TRADE_EVENING_SESSION: bool = False
    
    # Entry Filters
    REQUIRE_TREND_ALIGNMENT: bool = True
    MIN_TREND_TIMEFRAMES: int = 2
    AVOID_VOLATILITY_SPIKES: bool = True
    MAX_VOLATILITY_CHANGE: float = 0.5
    
    # Risk Management
    DAILY_LOSS_PCT: float = 3.0
    DAILY_PROFIT_PCT: float = 3.0
    MAX_DAILY_TRADES: int = 30  # Reduced for quality over quantity
    MAX_DRAWDOWN_PCT: float = 5.0
    MAX_CONSECUTIVE_LOSSES: int = 2  # Reduced from 3
    MAX_LOSS_PER_TRADE: float = 15.0
    LOSS_RECOVERY_MODE: bool = True
    LOSS_RECOVERY_LOT_MULTIPLIER: float = 0.5
    
    # Time Restrictions
    NO_TRADE_START: dt_time = dt_time(23, 0)
    NO_TRADE_END: dt_time = dt_time(0, 30)
    
    # Partial Close
    PARTIAL_CLOSE_ENABLED: bool = True
    PARTIAL_CLOSE_PCT: float = 0.5
    PARTIAL_CLOSE_MIN_VOL: float = 0.01
    
    # HYBRID SL Movement: 20% TP OR $7 profit
    TRAILING_ENABLED: bool = True
    TRAIL_STEP_PCT: float = 0.20
    MIN_PROFIT_FOR_MOVE: float = 7.0
    BREAKEVEN_AT_PCT: float = 0.20
    BREAKEVEN_MIN_PROFIT: float = 7.0
    
    # Market Regime Detection
    MARKET_REGIME_PERIOD: int = 50
    TRENDING_THRESHOLD: float = 0.5
    RANGING_THRESHOLD: float = 0.3
    
    # Signal Detection - MORE CONSERVATIVE FOR GOLD
    MIN_CONFIRMING_SIGNALS: int = 2
    CONSECUTIVE_LOSS_LIMIT: int = 2  # Reduced for gold
    
    # Performance Monitoring
    SUMMARY_INTERVAL: int = 1800
    MONITOR_INTERVAL: int = 30
    
    # Automation Settings
    AUTO_RECONNECT: bool = True
    MAX_RECONNECT_ATTEMPTS: int = 10
    RECONNECT_BACKOFF_BASE: float = 2.0
    DATA_CACHE_SECONDS: int = 60
    VALIDATE_SYMBOLS_ON_STARTUP: bool = True

config = BotConfig()

# ==================== AUTOMATED LOGGING SETUP ====================
class AutomatedLogger:
    """AUTOMATIC LOGGING SYSTEM - Creates all logs on startup"""
    
    def __init__(self):
        # Create timestamped folder for this run
        self.run_timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.log_dir = os.path.expanduser(fr"C:\Users\klajd\Documents\XAU_Bot_Logs\Run_{self.run_timestamp}")
        
        # Create directory if it doesn't exist
        os.makedirs(self.log_dir, exist_ok=True)
        
        # Define all log file paths
        self.log_files = {
            'main': os.path.join(self.log_dir, "trading_bot.log"),
            'trades': os.path.join(self.log_dir, "trade_log.csv"),
            'errors': os.path.join(self.log_dir, "error_log.csv"),
            'performance': os.path.join(self.log_dir, "performance_log.csv"),
            'sl_movements': os.path.join(self.log_dir, "sl_movement_log.csv"),
            'debug': os.path.join(self.log_dir, "debug_log.csv"),
            'signals': os.path.join(self.log_dir, "signals_log.csv"),
            'gold_patterns': os.path.join(self.log_dir, "gold_patterns_log.csv")
        }
        
        # Initialize all log files
        self._init_all_log_files()
        
        # Setup main logger with console and file output
        self.setup_main_logger()
        
        # Log startup
        self.logger.info("=" * 80)
        self.logger.info("GOLD-OPTIMIZED XAU BOT STARTUP")
        self.logger.info(f"Run Timestamp: {self.run_timestamp}")
        self.logger.info(f"Log Directory: {self.log_dir}")
        self.logger.info("=" * 80)
        self.logger.info("✅ ALL LOG FILES CREATED AUTOMATICALLY")
        
    def _init_all_log_files(self):
        """Initialize all CSV log files with headers"""
        
        # Trade Log
        with open(self.log_files['trades'], 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow([
                'timestamp', 'symbol', 'direction', 'entry_price', 'exit_price',
                'volume', 'profit', 'reason', 'status', 'sl_price', 'tp_price',
                'ticket', 'magic', 'consecutive_losses', 'market_session',
                'trend_alignment', 'volatility', 'signal_confidence'
            ])
        
        # Error Log
        with open(self.log_files['errors'], 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow([
                'timestamp', 'function', 'error_message', 'severity',
                'symbol', 'line_number', 'thread_id'
            ])
        
        # Performance Log
        with open(self.log_files['performance'], 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow([
                'timestamp', 'date', 'balance', 'equity', 'floating_pnl',
                'total_trades', 'win_rate', 'profit_factor', 'max_drawdown',
                'daily_trades', 'daily_pnl', 'consecutive_losses',
                'gold_specific_performance', 'avg_win', 'avg_loss'
            ])
        
        # SL Movement Log
        with open(self.log_files['sl_movements'], 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow([
                'timestamp', 'ticket', 'symbol', 'direction', 'entry_price',
                'current_price', 'old_sl', 'new_sl', 'tp_progress_pct',
                'profit_usd', 'reason', 'move_type', 'atr_value', 'session'
            ])
        
        # Debug Log
        with open(self.log_files['debug'], 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow([
                'timestamp', 'symbol', 'price', 'ema_fast', 'ema_slow',
                'rsi', 'atr', 'market_regime', 'signals_detected',
                'volume', 'spread', 'data_points', 'session', 'trend_score'
            ])
        
        # Signals Log
        with open(self.log_files['signals'], 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow([
                'timestamp', 'symbol', 'signal_direction', 'signal_type',
                'confidence', 'price', 'rsi', 'ema_alignment', 'volume_confirmation',
                'market_regime', 'confluence_count', 'action_taken', 'session_filter'
            ])
        
        # Gold Patterns Log
        with open(self.log_files['gold_patterns'], 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow([
                'timestamp', 'symbol', 'pattern_type', 'direction',
                'success', 'profit', 'session', 'volatility'
            ])
        
        self.logger = None
        
    def setup_main_logger(self):
        """Setup the main logging system"""
        self.logger = logging.getLogger("XAU_Bot_Gold_v17")
        self.logger.setLevel(logging.INFO)
        
        # Clear any existing handlers
        self.logger.handlers.clear()
        
        # File Handler
        fh = logging.FileHandler(
            self.log_files['main'],
            mode='a',
            encoding='utf-8'
        )
        
        # Console Handler
        ch = logging.StreamHandler()
        
        # Formatter
        fmt = logging.Formatter(
            "%(asctime)s | %(levelname)-8s | %(threadName)-15s | %(message)s",
            datefmt="%Y-%m-%d %H:%M:%S"
        )
        
        fh.setFormatter(fmt)
        ch.setFormatter(fmt)
        
        self.logger.addHandler(fh)
        self.logger.addHandler(ch)
    
    def log_trade(self, trade_data: Dict):
        """Log trade execution with gold-specific metrics"""
        try:
            with open(self.log_files['trades'], 'a', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                writer.writerow([
                    datetime.now().isoformat(),
                    trade_data.get('symbol', ''),
                    trade_data.get('direction', ''),
                    trade_data.get('entry_price', 0),
                    trade_data.get('exit_price', 0),
                    trade_data.get('volume', 0),
                    trade_data.get('profit', 0),
                    trade_data.get('reason', ''),
                    trade_data.get('status', ''),
                    trade_data.get('sl_price', 0),
                    trade_data.get('tp_price', 0),
                    trade_data.get('ticket', 0),
                    trade_data.get('magic', 0),
                    trade_data.get('consecutive_losses', 0),
                    trade_data.get('market_session', ''),
                    trade_data.get('trend_alignment', ''),
                    trade_data.get('volatility', 0),
                    trade_data.get('signal_confidence', 0)
                ])
            self.logger.info(f"Trade logged: {trade_data.get('symbol')} {trade_data.get('direction')}")
        except Exception as e:
            self.logger.error(f"Failed to log trade: {e}")
    
    def log_error(self, function: str, error_message: str, severity: str, symbol: str = None):
        """Log error to error CSV"""
        try:
            with open(self.log_files['errors'], 'a', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                writer.writerow([
                    datetime.now().isoformat(),
                    function,
                    error_message,
                    severity,
                    symbol or '',
                    '',  # line_number (we don't have this)
                    threading.current_thread().name  # thread_id
                ])
            self.logger.error(f"Error in {function}: {error_message}")
        except Exception as e:
            self.logger.error(f"Failed to log error: {e}")
    
    def log_debug(self, debug_data: Dict):
        """Log debug data to debug CSV"""
        try:
            with open(self.log_files['debug'], 'a', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                writer.writerow([
                    datetime.now().isoformat(),
                    debug_data.get('symbol', ''),
                    debug_data.get('price', 0),
                    debug_data.get('ema_fast', 0),
                    debug_data.get('ema_slow', 0),
                    debug_data.get('rsi', 0),
                    debug_data.get('atr', 0),
                    debug_data.get('market_regime', ''),
                    debug_data.get('signals_detected', ''),
                    debug_data.get('volume', 0),
                    debug_data.get('spread', 0),
                    debug_data.get('data_points', 0),
                    debug_data.get('session', ''),
                    debug_data.get('trend_score', 0)
                ])
        except Exception as e:
            self.logger.error(f"Failed to log debug data: {e}")
    
    def log_performance(self, performance_data: Dict):
        """Log performance data to performance CSV"""
        try:
            with open(self.log_files['performance'], 'a', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                writer.writerow([
                    datetime.now().isoformat(),
                    performance_data.get('date', ''),
                    performance_data.get('balance', 0),
                    performance_data.get('equity', 0),
                    performance_data.get('floating_pnl', 0),
                    performance_data.get('total_trades', 0),
                    performance_data.get('win_rate', 0),
                    performance_data.get('profit_factor', 0),
                    performance_data.get('max_drawdown', 0),
                    performance_data.get('daily_trades', 0),
                    performance_data.get('daily_pnl', 0),
                    performance_data.get('consecutive_losses', 0),
                    performance_data.get('gold_specific_performance', ''),
                    performance_data.get('avg_win', 0),
                    performance_data.get('avg_loss', 0)
                ])
        except Exception as e:
            self.logger.error(f"Failed to log performance data: {e}")
    
    def log_sl_movement(self, sl_data: Dict):
        """Log SL movement to CSV"""
        try:
            with open(self.log_files['sl_movements'], 'a', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                writer.writerow([
                    datetime.now().isoformat(),
                    sl_data.get('ticket', 0),
                    sl_data.get('symbol', ''),
                    sl_data.get('direction', ''),
                    sl_data.get('entry_price', 0),
                    sl_data.get('current_price', 0),
                    sl_data.get('old_sl', 0),
                    sl_data.get('new_sl', 0),
                    sl_data.get('tp_progress_pct', 0),
                    sl_data.get('profit_usd', 0),
                    sl_data.get('reason', ''),
                    sl_data.get('move_type', ''),
                    sl_data.get('atr_value', 0),
                    sl_data.get('session', '')
                ])
        except Exception as e:
            self.logger.error(f"Failed to log SL movement: {e}")
    
    def log_signal(self, signal_data: Dict):
        """Log signal to signals CSV"""
        try:
            with open(self.log_files['signals'], 'a', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                writer.writerow([
                    datetime.now().isoformat(),
                    signal_data.get('symbol', ''),
                    signal_data.get('signal_direction', ''),
                    signal_data.get('signal_type', ''),
                    signal_data.get('confidence', 0),
                    signal_data.get('price', 0),
                    signal_data.get('rsi', 0),
                    signal_data.get('ema_alignment', ''),
                    signal_data.get('volume_confirmation', False),
                    signal_data.get('market_regime', ''),
                    signal_data.get('confluence_count', 0),
                    signal_data.get('action_taken', ''),
                    signal_data.get('session_filter', '')
                ])
        except Exception as e:
            self.logger.error(f"Failed to log signal: {e}")
    
    def log_gold_pattern(self, pattern_data: Dict):
        """Log gold pattern to CSV"""
        try:
            with open(self.log_files['gold_patterns'], 'a', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                writer.writerow([
                    datetime.now().isoformat(),
                    pattern_data.get('symbol', ''),
                    pattern_data.get('pattern_type', ''),
                    pattern_data.get('direction', ''),
                    pattern_data.get('success', ''),
                    pattern_data.get('profit', 0),
                    pattern_data.get('session', ''),
                    pattern_data.get('volatility', 0)
                ])
        except Exception as e:
            self.logger.error(f"Failed to log gold pattern: {e}")
    
    def info(self, message: str):
        """Log info message"""
        self.logger.info(message)
    
    def warning(self, message: str):
        """Log warning message"""
        self.logger.warning(message)
    
    def error(self, message: str):
        """Log error message"""
        self.logger.error(message)
    
    def debug(self, message: str):
        """Log debug message"""
        self.logger.debug(message)
    
    def critical(self, message: str):
        """Log critical message"""
        self.logger.critical(message)

# Initialize automated logger
logger = AutomatedLogger()

# ==================== GOLD VOLATILITY ADAPTOR ====================
class GoldVolatilityAdaptor:
    """Specialized for Gold/XAU volatility patterns"""
    
    def __init__(self):
        self.xau_atr_cache = {}
        self.volatility_history = defaultdict(list)
        
    def get_xau_volatility_multiplier(self, symbol: str, current_atr: float) -> float:
        """Gold-specific volatility adjustments"""
        if "XAUUSD" in symbol:
            # Gold typically needs wider stops
            if current_atr < 1.0:
                return 2.0  # Low volatility, tighten slightly
            elif current_atr < 2.0:
                return 1.5  # Normal volatility
            else:
                return 1.2  # High volatility, be careful
        elif "XAUJPY" in symbol:
            # XAUJPY has different volatility characteristics
            if current_atr < 100:  # XAUJPY ATR in JPY
                return 1.5
            elif current_atr < 200:
                return 1.3
            else:
                return 1.1
        return 1.5
    
    def should_avoid_trading(self, symbol: str, current_atr: float, 
                           previous_atr: float) -> bool:
        """Avoid trading during extreme volatility spikes"""
        if previous_atr > 0:
            volatility_change = abs(current_atr - previous_atr) / previous_atr
            if volatility_change > config.MAX_VOLATILITY_CHANGE:
                logger.warning(f"{symbol}: Avoiding trade - volatility spike detected ({volatility_change:.1%})")
                return True
            
            # Track volatility history
            self.volatility_history[symbol].append(current_atr)
            if len(self.volatility_history[symbol]) > 20:
                self.volatility_history[symbol].pop(0)
            
            # Check if volatility is too high historically
            if len(self.volatility_history[symbol]) >= 10:
                avg_volatility = np.mean(self.volatility_history[symbol])
                if current_atr > avg_volatility * 1.5:
                    logger.warning(f"{symbol}: Current volatility {current_atr:.2f} > 1.5x average {avg_volatility:.2f}")
                    return True
        
        return False
    
    def get_gold_specific_atr(self, symbol: str, df: pd.DataFrame) -> float:
        """Get ATR adjusted for gold characteristics"""
        if df.empty or len(df) < config.ATR_PERIOD:
            return config.GOLD_MIN_ATR if "XAUUSD" in symbol else 100
        
        try:
            atr = AverageTrueRange(df['high'], df['low'], df['close'], config.ATR_PERIOD).average_true_range()
            atr_value = float(atr.iloc[-1])
            
            # Ensure minimum ATR for gold
            if "XAUUSD" in symbol and atr_value < config.GOLD_MIN_ATR:
                return config.GOLD_MIN_ATR
            elif "XAUJPY" in symbol and atr_value < 50:
                return 50
            
            return atr_value
        except Exception as e:
            logger.error(f"Error calculating gold ATR: {e}")
            return config.GOLD_MIN_ATR if "XAUUSD" in symbol else 100

# Initialize volatility adaptor
volatility_adaptor = GoldVolatilityAdaptor()

# ==================== SESSION FILTER ====================
class SessionFilter:
    """Filter trades based on market session for gold"""
    
    @staticmethod
    def get_current_session() -> str:
        """Get current trading session"""
        current_hour = datetime.now().hour
        current_weekday = datetime.now().weekday()
        
        # Asian session: 00:00-08:00 GMT
        # London session: 08:00-16:00 GMT  
        # NY session: 13:00-21:00 GMT
        
        if current_weekday >= 5:  # Weekend
            return "weekend"
        elif 0 <= current_hour < 8:
            return "asian"
        elif 8 <= current_hour < 13:
            return "london"
        elif 13 <= current_hour < 21:
            return "newyork"
        else:
            return "evening"
    
    @staticmethod
    def should_trade_in_session(symbol: str) -> bool:
        """Gold has specific session behaviors"""
        session = SessionFilter.get_current_session()
        
        logger.debug(f"Current session: {session} for {symbol}")
        
        if "XAU" in symbol:
            if session == "asian" and not config.TRADE_ASIAN_SESSION:
                logger.info(f"{symbol}: Asian session - being conservative")
                return False
            elif session == "london" and config.TRADE_LONDON_SESSION:
                return True
            elif session == "newyork" and config.TRADE_NY_SESSION:
                return True
            elif session == "evening" and not config.TRADE_EVENING_SESSION:
                return False
            elif session == "weekend":
                return False
        
        return True
    
    @staticmethod
    def get_session_multiplier(symbol: str) -> float:
        """Get multiplier based on session for gold"""
        session = SessionFilter.get_current_session()
        
        if "XAU" in symbol:
            if session == "london":
                return 1.0  # Normal trading
            elif session == "newyork":
                return 0.9  # Slightly more conservative in NY
            elif session == "asian":
                return 0.7  # Much more conservative in Asian
            else:
                return 0.8  # Evening sessions
        
        return 1.0

# ==================== TREND CONFIRMATION ENHANCEMENT ====================
def enhanced_trend_confirmation(symbol: str, direction: str) -> bool:
    """Stricter trend confirmation for gold"""
    if not config.REQUIRE_TREND_ALIGNMENT:
        return True
    
    try:
        # Get multiple timeframe data
        df_m5 = get_bars_enhanced(symbol, mt5.TIMEFRAME_M5, 50)
        df_m15 = get_bars_enhanced(symbol, mt5.TIMEFRAME_M15, 50)
        df_h1 = get_bars_enhanced(symbol, mt5.TIMEFRAME_H1, 50)
        
        if df_m5.empty or df_m15.empty or df_h1.empty:
            logger.warning(f"{symbol}: Insufficient data for trend confirmation")
            return False  # Be conservative if data missing
        
        # Calculate EMAs on all timeframes
        for df, tf_name in [(df_m5, "M5"), (df_m15, "M15"), (df_h1, "H1")]:
            df['ema_fast'] = df['close'].ewm(span=config.EMA_FAST).mean()
            df['ema_slow'] = df['close'].ewm(span=config.EMA_SLOW).mean()
        
        # Check alignment across timeframes
        m5_bullish = df_m5['ema_fast'].iloc[-1] > df_m5['ema_slow'].iloc[-1]
        m15_bullish = df_m15['ema_fast'].iloc[-1] > df_m15['ema_slow'].iloc[-1]
        h1_bullish = df_h1['ema_fast'].iloc[-1] > df_h1['ema_slow'].iloc[-1]
        
        bullish_alignment = sum([m5_bullish, m15_bullish, h1_bullish])
        
        if direction == 'buy':
            # Require at least 2 timeframes bullish
            result = bullish_alignment >= config.MIN_TREND_TIMEFRAMES
            logger.info(f"{symbol} Buy trend confirmation: M5={m5_bullish}, M15={m15_bullish}, H1={h1_bullish} -> {result}")
            return result
        else:  # sell
            # Require at least 2 timeframes bearish (not bullish)
            bearish_alignment = 3 - bullish_alignment
            result = bearish_alignment >= config.MIN_TREND_TIMEFRAMES
            logger.info(f"{symbol} Sell trend confirmation: M5={not m5_bullish}, M15={not m15_bullish}, H1={not h1_bullish} -> {result}")
            return result
            
    except Exception as e:
        logger.error(f"Trend confirmation error for {symbol}: {e}")
        return False  # Be conservative on error

# ==================== ENTRY TIMING IMPROVEMENT ====================
def smart_entry_timing(symbol: str, direction: str) -> bool:
    """Wait for better entry timing to avoid false breakouts"""
    try:
        df = get_bars_enhanced(symbol, mt5.TIMEFRAME_M5, 20)
        if df.empty:
            return True
        
        current_price = df['close'].iloc[-1]
        prev_candle = df.iloc[-2]
        
        # Calculate ATR for volatility check
        if 'atr' not in df.columns:
            df['atr'] = AverageTrueRange(df['high'], df['low'], df['close'], config.ATR_PERIOD).average_true_range()
        
        current_atr = df['atr'].iloc[-1] if not pd.isna(df['atr'].iloc[-1]) else 0
        
        # Check if we're entering after a big move (might be exhaustion)
        if current_atr > 0:
            move_size = abs(current_price - prev_candle['close'])
            if move_size > current_atr * 1.5:
                logger.info(f"{symbol}: Waiting - large move detected ({move_size:.2f} > {current_atr*1.5:.2f})")
                return False
        
        # Check for recent volatility
        recent_high = df['high'].iloc[-5:].max()
        recent_low = df['low'].iloc[-5:].min()
        recent_range = recent_high - recent_low
        
        if current_atr > 0 and recent_range > current_atr * 3:
            logger.info(f"{symbol}: Waiting - high recent volatility")
            return False
        
        # Check for pin bars at key levels
        body = abs(prev_candle['close'] - prev_candle['open'])
        upper_wick = prev_candle['high'] - max(prev_candle['close'], prev_candle['open'])
        lower_wick = min(prev_candle['close'], prev_candle['open']) - prev_candle['low']
        
        is_pin_bull = lower_wick > body * 2 and upper_wick < body * 0.5
        is_pin_bear = upper_wick > body * 2 and lower_wick < body * 0.5
        
        if is_pin_bull and direction == 'sell':
            logger.info(f"{symbol}: Waiting - bullish pin bar against sell direction")
            return False
        elif is_pin_bear and direction == 'buy':
            logger.info(f"{symbol}: Waiting - bearish pin bar against buy direction")
            return False
        
        return True
        
    except Exception as e:
        logger.error(f"Entry timing error for {symbol}: {e}")
        return True

# ==================== AUTOMATIC CONNECTION MANAGER ====================
class ConnectionManager:
    """AUTOMATIC CONNECTION MANAGEMENT with exponential backoff"""
    
    def __init__(self):
        self.connected = False
        self.last_connection_check = 0
        self.reconnect_attempts = 0
        self.max_reconnect_attempts = config.MAX_RECONNECT_ATTEMPTS
        self.backoff_base = config.RECONNECT_BACKOFF_BASE
        
    def initialize_with_retry(self) -> float:
        """Initialize MT5 with exponential backoff retry"""
        attempt = 0
        
        while attempt < self.max_reconnect_attempts:
            try:
                logger.info(f"MT5 Connection Attempt {attempt + 1}/{self.max_reconnect_attempts}")
                
                if not mt5.initialize(login=config.LOGIN, password=config.PASSWORD, server=config.SERVER):
                    error_msg = f"MT5 initialize failed: {mt5.last_error()}"
                    logger.error(error_msg)
                    logger.log_error("initialize_with_retry", error_msg, "ERROR")
                    
                    attempt += 1
                    self.reconnect_attempts = attempt
                    
                    # Exponential backoff
                    wait_time = self.backoff_base ** attempt
                    logger.warning(f"Waiting {wait_time:.1f} seconds before retry...")
                    time.sleep(wait_time)
                    continue
                
                # Validate account info
                acct = mt5.account_info()
                if acct is None:
                    error_msg = "Account info unavailable after connection"
                    logger.error(error_msg)
                    logger.log_error("initialize_with_retry", error_msg, "ERROR")
                    mt5.shutdown()
                    
                    attempt += 1
                    self.reconnect_attempts = attempt
                    wait_time = self.backoff_base ** attempt
                    time.sleep(wait_time)
                    continue
                
                # Validate symbols if configured
                if config.VALIDATE_SYMBOLS_ON_STARTUP:
                    self.validate_all_symbols()
                
                self.connected = True
                self.reconnect_attempts = 0
                self.last_connection_check = time.time()
                
                logger.info(f"✅ MT5 Connected Successfully")
                logger.info(f"Account: {acct.login}, Balance: ${acct.balance:.2f}")
                
                return float(acct.balance)
                
            except Exception as e:
                error_msg = f"Connection error: {str(e)}"
                logger.error(error_msg)
                logger.log_error("initialize_with_retry", error_msg, "CRITICAL")
                
                attempt += 1
                self.reconnect_attempts = attempt
                
                if attempt < self.max_reconnect_attempts:
                    wait_time = self.backoff_base ** attempt
                    logger.warning(f"Retrying in {wait_time:.1f} seconds...")
                    time.sleep(wait_time)
                else:
                    logger.critical(f"Max reconnection attempts reached ({self.max_reconnect_attempts})")
                    raise SystemExit(f"Failed to connect to MT5 after {self.max_reconnect_attempts} attempts")
        
        raise SystemExit("MT5 connection failed")
    
    def validate_all_symbols(self):
        """Validate all trading symbols on startup"""
        logger.info("Validating trading symbols...")
        
        for symbol in config.SYMBOLS:
            try:
                info = mt5.symbol_info(symbol)
                if info is None:
                    logger.error(f"❌ Symbol {symbol} not found!")
                    logger.log_error("validate_all_symbols", f"Symbol {symbol} not found", "ERROR")
                else:
                    logger.info(f"✅ Symbol {symbol} validated")
                    logger.debug(f"  Point: {info.point}, Spread: {info.spread}")
            except Exception as e:
                logger.error(f"Error validating symbol {symbol}: {e}")
                logger.log_error("validate_all_symbols", str(e), "WARNING", symbol)
    
    def check_connection(self) -> bool:
        """Check if MT5 connection is still active"""
        try:
            current_time = time.time()
            
            # Only check every 30 seconds to avoid overhead
            if current_time - self.last_connection_check < config.MONITOR_INTERVAL:
                return self.connected
            
            self.last_connection_check = current_time
            
            # Try to get account info
            acct = mt5.account_info()
            
            if acct is None:
                logger.warning("MT5 connection lost - account info unavailable")
                self.connected = False
                return False
            
            self.connected = True
            return True
            
        except Exception as e:
            logger.error(f"Connection check failed: {e}")
            self.connected = False
            return False
    
    def reconnect_if_needed(self) -> bool:
        """Auto-reconnect if connection is lost"""
        if not self.connected or not self.check_connection():
            logger.warning("Connection lost, attempting to reconnect...")
            
            try:
                mt5.shutdown()
                time.sleep(2)
                
                # Try to reconnect
                self.initialize_with_retry()
                
                if self.connected:
                    logger.info("✅ Successfully reconnected to MT5")
                    return True
                else:
                    logger.error("Failed to reconnect to MT5")
                    return False
                    
            except Exception as e:
                logger.error(f"Reconnection failed: {e}")
                logger.log_error("reconnect_if_needed", str(e), "CRITICAL")
                return False
        
        return True

# Initialize connection manager
connection_manager = ConnectionManager()

# ==================== TRADE TRACKER FOR HYBRID SL MOVEMENT ====================
class TradeTracker:
    """Track individual trades for hybrid SL movement with safety limits"""
    
    def __init__(self):
        self.trades = {}
        self.consecutive_losses = 0
        self.lock = threading.RLock()
        self.max_loss_per_trade = config.MAX_LOSS_PER_TRADE
    
    def add_trade(self, ticket: int, symbol: str, direction: str, 
                  entry_price: float, sl_price: float, tp_price: float):
        """Add a new trade to track with safety checks"""
        with self.lock:
            # Get symbol info for point value calculation
            info = mt5.symbol_info(symbol)
            point = info.point if info else 0.01
            
            # Calculate maximum allowed loss based on position size
            lot_size = config.LOT_FIXED
            risk_per_point = self._calculate_risk_per_point(symbol, lot_size)
            
            if direction == 'buy':
                stop_distance_points = (entry_price - sl_price) / point
                potential_loss = abs(stop_distance_points * risk_per_point)
            else:
                stop_distance_points = (sl_price - entry_price) / point
                potential_loss = abs(stop_distance_points * risk_per_point)
            
            # Check if potential loss exceeds maximum
            if potential_loss > self.max_loss_per_trade:
                logger.warning(f"Potential loss ${potential_loss:.2f} exceeds maximum ${self.max_loss_per_trade}")
                logger.log_error("add_trade", 
                               f"Potential loss ${potential_loss:.2f} > Max ${self.max_loss_per_trade}",
                               "WARNING", symbol)
            
            self.trades[ticket] = {
                'symbol': symbol,
                'direction': direction,
                'entry_price': entry_price,
                'original_sl': sl_price,
                'tp_price': tp_price,
                'current_sl': sl_price,
                'last_move_percentage': 0.0,
                'last_move_profit_usd': 0.0,
                'move_thresholds': self._calculate_move_thresholds(entry_price, tp_price, direction),
                'profit_thresholds': self._calculate_profit_thresholds(entry_price, tp_price, direction, point, risk_per_point),
                'breakeven_moved': False,
                'partial_closed': False,
                'point_value': point,
                'risk_per_point': risk_per_point,
                'potential_loss': potential_loss,
                'lot_size': lot_size,
                'max_loss_exceeded': potential_loss > self.max_loss_per_trade
            }
            
            logger.info(f"Trade {ticket} added to tracker. Potential loss: ${potential_loss:.2f}")
    
    def _calculate_risk_per_point(self, symbol: str, lot_size: float) -> float:
        """Calculate risk per point for the symbol"""
        # Gold-specific risk calculation
        if "XAUUSD" in symbol:
            # XAUUSD: 1 lot = 100 oz, 1 point = $0.01 per oz
            # For 0.01 lot: 1 point ≈ $0.01
            return lot_size * 100 * 0.01
        elif "XAUJPY" in symbol:
            # XAUJPY: Different calculation needed
            return lot_size * 10  # Adjust based on your broker
        return lot_size * 100 * 0.01
    
    def _calculate_move_thresholds(self, entry_price: float, tp_price: float, direction: str) -> List[Tuple[float, float]]:
        """Calculate price thresholds for SL movement every 20% of TP"""
        thresholds = []
        
        if direction == 'buy':
            tp_distance = tp_price - entry_price
            percentages = [0.2, 0.4, 0.6, 0.8, 1.0]
            for pct in percentages:
                threshold_price = entry_price + (tp_distance * pct)
                thresholds.append((pct, threshold_price))
        else:  # sell
            tp_distance = entry_price - tp_price
            percentages = [0.2, 0.4, 0.6, 0.8, 1.0]
            for pct in percentages:
                threshold_price = entry_price - (tp_distance * pct)
                thresholds.append((pct, threshold_price))
        
        return thresholds
    
    def _calculate_profit_thresholds(self, entry_price: float, tp_price: float, 
                                   direction: str, point: float, risk_per_point: float) -> List[Tuple[float, float]]:
        """Calculate profit thresholds in USD for $7 increments with safety"""
        thresholds = []
        
        # Calculate maximum profit points
        if direction == 'buy':
            max_profit_points = (tp_price - entry_price) / point
        else:
            max_profit_points = (entry_price - tp_price) / point
        
        # Generate thresholds every $7 profit
        for profit_usd in range(7, int(config.MAX_LOSS_PER_TRADE * 2), 7):
            profit_points = profit_usd / risk_per_point
            if profit_points <= max_profit_points:
                if direction == 'buy':
                    price_threshold = entry_price + (profit_points * point)
                else:
                    price_threshold = entry_price - (profit_points * point)
                thresholds.append((profit_usd, price_threshold))
        
        return thresholds
    
    def update_consecutive_losses(self, profit: float):
        """Track consecutive losses for safety pausing"""
        with self.lock:
            if profit < 0:
                self.consecutive_losses += 1
                logger.warning(f"Consecutive losses: {self.consecutive_losses}/{config.CONSECUTIVE_LOSS_LIMIT}")
                
                if self.consecutive_losses >= config.CONSECUTIVE_LOSS_LIMIT:
                    logger.critical(f"⚠️ PAUSING TRADING: {self.consecutive_losses} consecutive losses!")
                    logger.log_error("update_consecutive_losses", 
                                   f"{self.consecutive_losses} consecutive losses - Trading paused",
                                   "CRITICAL")
            else:
                self.consecutive_losses = 0
    
    def should_pause_trading(self) -> bool:
        """Check if trading should be paused due to consecutive losses"""
        with self.lock:
            return self.consecutive_losses >= config.CONSECUTIVE_LOSS_LIMIT
    
    def calculate_current_profit_usd(self, ticket: int, current_price: float) -> float:
        """Calculate current profit in USD"""
        with self.lock:
            if ticket not in self.trades:
                return 0.0
            
            trade = self.trades[ticket]
            direction = trade['direction']
            entry_price = trade['entry_price']
            
            if direction == 'buy':
                points = (current_price - entry_price) / trade['point_value']
            else:
                points = (entry_price - current_price) / trade['point_value']
            
            profit_usd = points * trade['risk_per_point']
            return profit_usd
    
    def update_trade(self, ticket: int, current_price: float) -> Optional[Tuple[float, str]]:
        """Update trade and return (new_sl, reason) if needed"""
        with self.lock:
            if ticket not in self.trades:
                return None
            
            trade = self.trades[ticket]
            direction = trade['direction']
            entry_price = trade['entry_price']
            tp_price = trade['tp_price']
            current_sl = trade['current_sl']
            
            # Calculate TP progress percentage
            if direction == 'buy':
                tp_distance = tp_price - entry_price
                current_progress = current_price - entry_price
            else:
                tp_distance = entry_price - tp_price
                current_progress = entry_price - current_price
            
            if tp_distance == 0:
                return None
            
            progress_pct = current_progress / tp_distance
            
            # Calculate current profit in USD
            current_profit_usd = self.calculate_current_profit_usd(ticket, current_price)
            
            # REASON 1: Check for breakeven move (20% of TP AND minimum $7 profit)
            if not trade['breakeven_moved']:
                should_move_breakeven = False
                reason = ""
                
                # Check TP percentage condition
                if progress_pct >= config.BREAKEVEN_AT_PCT:
                    should_move_breakeven = True
                    reason = f"Breakeven at {progress_pct*100:.1f}% of TP"
                
                # Check minimum profit condition
                if current_profit_usd >= config.BREAKEVEN_MIN_PROFIT:
                    should_move_breakeven = True
                    reason = f"Breakeven at ${current_profit_usd:.2f} profit"
                
                if should_move_breakeven:
                    new_sl = entry_price
                    if (direction == 'buy' and new_sl > current_sl) or \
                       (direction == 'sell' and new_sl < current_sl):
                        trade['current_sl'] = new_sl
                        trade['breakeven_moved'] = True
                        trade['last_move_percentage'] = progress_pct
                        trade['last_move_profit_usd'] = current_profit_usd
                        logger.info(f"Moving to breakeven: {reason}")
                        return (new_sl, f"breakeven_{reason}")
            
            # REASON 2: Check for 20% TP increment moves
            target_threshold_pct = 0
            for pct, threshold_price in trade['move_thresholds']:
                if direction == 'buy' and current_price >= threshold_price:
                    target_threshold_pct = pct
                elif direction == 'sell' and current_price <= threshold_price:
                    target_threshold_pct = pct
            
            # REASON 3: Check for $7 profit increment moves
            target_profit_usd = 0
            for profit_usd, threshold_price in trade['profit_thresholds']:
                if direction == 'buy' and current_price >= threshold_price:
                    target_profit_usd = profit_usd
                elif direction == 'sell' and current_price <= threshold_price:
                    target_profit_usd = profit_usd
            
            # Determine which threshold triggered
            move_triggered = False
            move_reason = ""
            
            if target_threshold_pct > trade['last_move_percentage']:
                move_triggered = True
                move_reason = f"{target_threshold_pct*100:.0f}%_TP"
            elif target_profit_usd > trade['last_move_profit_usd']:
                move_triggered = True
                move_reason = f"${target_profit_usd}_profit"
            
            # Move SL if either condition is met
            if move_triggered:
                # Calculate new SL: Move to 40% behind current price (conservative)
                if direction == 'buy':
                    sl_distance = (tp_price - entry_price) * 0.40
                    new_sl = current_price - sl_distance
                    # Ensure SL doesn't go below entry price
                    new_sl = max(new_sl, entry_price, current_sl)
                else:  # sell
                    sl_distance = (entry_price - tp_price) * 0.40
                    new_sl = current_price + sl_distance
                    # Ensure SL doesn't go above entry price
                    new_sl = min(new_sl, entry_price, current_sl)
                
                if (direction == 'buy' and new_sl > current_sl) or \
                   (direction == 'sell' and new_sl < current_sl):
                    trade['current_sl'] = new_sl
                    trade['last_move_percentage'] = max(trade['last_move_percentage'], target_threshold_pct)
                    trade['last_move_profit_usd'] = max(trade['last_move_profit_usd'], target_profit_usd)
                    logger.info(f"Moving SL: {move_reason}, new SL: {new_sl:.5f}")
                    return (new_sl, move_reason)
            
            return None
    
    def remove_trade(self, ticket: int):
        with self.lock:
            if ticket in self.trades:
                del self.trades[ticket]
    
    def get_trade(self, ticket: int):
        with self.lock:
            return self.trades.get(ticket)

# Initialize trade tracker
trade_tracker = TradeTracker()

# ==================== ENHANCED DATA CACHE ====================
class EnhancedDataCache:
    """INTELLIGENT DATA CACHING with automatic retry"""
    
    def __init__(self, cache_seconds: int = config.DATA_CACHE_SECONDS):
        self.cache = {}
        self.cache_timestamps = {}
        self.cache_seconds = cache_seconds
        self.max_retries = 3
    
    def get_cached_data(self, symbol: str, timeframe: int, bars_needed: int) -> Optional[pd.DataFrame]:
        """Get cached data if available and fresh"""
        key = f"{symbol}_{timeframe}"
        
        if key in self.cache:
            cached_time = self.cache_timestamps.get(key, 0)
            current_time = time.time()
            
            # Check if cache is still valid
            if current_time - cached_time < self.cache_seconds:
                cached_df = self.cache[key]
                if len(cached_df) >= bars_needed:
                    return cached_df.copy()
        
        return None
    
    def get_data_with_retry(self, symbol: str, timeframe: int, n: int = 400) -> pd.DataFrame:
        """Get data with automatic retry on failure"""
        for attempt in range(self.max_retries):
            try:
                cached_data = self.get_cached_data(symbol, timeframe, n)
                if cached_data is not None:
                    return cached_data
                
                # Fetch fresh data
                rates = mt5.copy_rates_from_pos(symbol, timeframe, 0, n)
                if rates is None or len(rates) == 0:
                    raise ValueError(f"No data returned for {symbol}")
                
                df = pd.DataFrame(rates)
                df['time'] = pd.to_datetime(df['time'], unit='s')
                
                # Update cache
                self.cache[f"{symbol}_{timeframe}"] = df.copy()
                self.cache_timestamps[f"{symbol}_{timeframe}"] = time.time()
                
                logger.debug(f"Data fetched for {symbol} TF{timeframe}, {len(df)} bars")
                return df
                
            except Exception as e:
                logger.warning(f"Data fetch attempt {attempt + 1} failed for {symbol}: {e}")
                
                if attempt < self.max_retries - 1:
                    wait_time = 2 ** attempt  # Exponential backoff
                    time.sleep(wait_time)
                else:
                    logger.error(f"Failed to fetch data for {symbol} after {self.max_retries} attempts")
                    logger.log_error("get_data_with_retry", str(e), "ERROR", symbol)
                    return pd.DataFrame()
        
        return pd.DataFrame()

# Initialize enhanced data cache
data_cache = EnhancedDataCache()

# ==================== SOUND SETUP ====================
_have_winsound = False
try:
    import winsound
    _have_winsound = True
except Exception:
    _have_winsound = False

def find_cash_wav():
    candidates = []
    candidates.append(os.path.join(os.getcwd(), "cash.wav"))
    candidates.append(os.path.join(os.path.expanduser("~"), "cash.wav"))
    try:
        script_dir = os.path.dirname(os.path.realpath(__file__))
        candidates.append(os.path.join(script_dir, "cash.wav"))
    except Exception:
        pass
    try:
        tinfo = mt5.terminal_info()
        for attr in ("data_path", "path", "common_data_path", "terminal_path"):
            if hasattr(tinfo, attr):
                base = getattr(tinfo, attr)
                candidates.append(os.path.join(base, "MQL5", "Sounds", "cash.wav"))
                candidates.append(os.path.join(base, "MQL4", "Sounds", "cash.wav"))
    except Exception:
        pass
    return [p for p in candidates if p and os.path.isfile(p)]

def play_wav_or_beep(kind="buy"):
    candidates = find_cash_wav()
    if hasattr(logger, 'log_dir'):
        candidates.append(os.path.join(logger.log_dir, "cash.wav"))
    for p in candidates:
        if p and os.path.isfile(p):
            try:
                if _have_winsound:
                    winsound.PlaySound(p, winsound.SND_FILENAME | winsound.SND_ASYNC)
                    return
            except Exception:
                pass
    if _have_winsound:
        try:
            if kind == "buy":
                winsound.Beep(1400, 70); winsound.Beep(1600, 60); winsound.Beep(1900, 90)
            elif kind == "sell":
                winsound.Beep(600, 70); winsound.Beep(520, 60); winsound.Beep(420, 90)
            else:
                winsound.Beep(1000, 80)
        except Exception:
            pass

def beep_cash_buy():
    play_wav_or_beep("buy")

def beep_cash_sell():
    play_wav_or_beep("sell")

def beep_cash_partial():
    play_wav_or_beep("partial")

def trade_flash(message):
    try:
        print("\n" + "="*60)
        print("💰💰💰  " + message + "  💰💰💰")
        print("="*60 + "\n")
    except Exception:
        pass

# ==================== INITIALIZE MT5 WITH AUTOMATIC RECOVERY ====================
def initialize_mt5_with_recovery() -> float:
    """Initialize MT5 with automatic recovery"""
    logger.info("Initializing MT5 with automatic recovery...")
    return connection_manager.initialize_with_retry()

STARTING_BALANCE = initialize_mt5_with_recovery()

# ==================== ENHANCED GLOBAL STATE MANAGEMENT ====================
class EnhancedGlobalState:
    """Enhanced global state with gold-specific features"""
    
    def __init__(self):
        self.daily_start_date = date.today()
        self.daily_trades_count = 0
        self.daily_loss_triggered = False
        self.last_summary_time = time.time()
        self.peak_equity = STARTING_BALANCE
        self.max_drawdown = 0.0
        self.last_trade_time = {s: 0 for s in config.SYMBOLS}
        self.last_forced_time = {s: 0 for s in config.SYMBOLS}
        self.signal_stats = self._load_learning_stats()
        self.market_regimes = {s: "unknown" for s in config.SYMBOLS}
        self.consecutive_losses_by_symbol = {s: 0 for s in config.SYMBOLS}
        self.signal_strength = {s: 0 for s in config.SYMBOLS}
        self.session_profits = defaultdict(float)
        self.lock = threading.RLock()
    
    def _load_learning_stats(self):
        stats = {}
        learning_file = os.path.join(os.path.expanduser("~"), "Documents", "gold_trade_learning_log.csv")
        
        try:
            if os.path.exists(learning_file):
                with open(learning_file, 'r', newline='') as f:
                    reader = csv.DictReader(f)
                    for row in reader:
                        sym = row.get("symbol", "")
                        sig = row.get("direction", "")
                        res = (row.get("result") or "").lower()
                        if not sym or not sig:
                            continue
                        
                        if sym not in stats:
                            stats[sym] = {}
                        if sig not in stats[sym]:
                            stats[sym][sig] = {"wins": 0, "losses": 0, "total": 0}
                        
                        if res.startswith("win"):
                            stats[sym][sig]["wins"] += 1
                        elif res.startswith("loss"):
                            stats[sym][sig]["losses"] += 1
                        
                        stats[sym][sig]["total"] += 1
                        
                logger.info(f"Loaded learning stats for {len(stats)} symbols")
        except Exception as e:
            logger.error(f"Error loading learning stats: {e}")
            logger.log_error("_load_learning_stats", str(e), "WARNING")
        
        return stats
    
    def update_consecutive_losses(self, symbol: str, profit: float):
        """Update consecutive losses for a symbol"""
        with self.lock:
            if profit < 0:
                self.consecutive_losses_by_symbol[symbol] += 1
                logger.warning(f"{symbol}: Consecutive losses: {self.consecutive_losses_by_symbol[symbol]}")
            else:
                self.consecutive_losses_by_symbol[symbol] = 0
    
    def should_pause_symbol(self, symbol: str) -> bool:
        """Check if trading should be paused for a symbol"""
        with self.lock:
            return self.consecutive_losses_by_symbol.get(symbol, 0) >= config.CONSECUTIVE_LOSS_LIMIT
    
    def update_learning(self, symbol: str, signal: str, outcome: str, profit: float = 0):
        with self.lock:
            try:
                if symbol not in self.signal_stats:
                    self.signal_stats[symbol] = {}
                if signal not in self.signal_stats[symbol]:
                    self.signal_stats[symbol][signal] = {"wins": 0, "losses": 0, "total": 0}
                
                if outcome == "win":
                    self.signal_stats[symbol][signal]["wins"] += 1
                elif outcome == "loss":
                    self.signal_stats[symbol][signal]["losses"] += 1
                
                self.signal_stats[symbol][signal]["total"] += 1
                
                # Update session profits
                session = SessionFilter.get_current_session()
                self.session_profits[session] += profit
                
            except Exception as e:
                logger.error(f"Error updating learning: {e}")
                logger.log_error("update_learning", str(e), "WARNING")
    
    def get_signal_win_rate(self, symbol: str, signal: str) -> float:
        with self.lock:
            try:
                if (symbol in self.signal_stats and 
                    signal in self.signal_stats[symbol] and 
                    self.signal_stats[symbol][signal]["total"] > 0):
                    
                    stats = self.signal_stats[symbol][signal]
                    return stats["wins"] / stats["total"]
            except Exception:
                pass
            return 0.5  # Conservative default for gold
    
    def update_signal_strength(self, symbol: str, strength: int):
        """Update signal strength for a symbol"""
        with self.lock:
            self.signal_strength[symbol] = strength
    
    def get_signal_strength(self, symbol: str) -> int:
        """Get current signal strength for a symbol"""
        with self.lock:
            return self.signal_strength.get(symbol, 0)
    
    def update_daily_stats(self):
        with self.lock:
            try:
                if not connection_manager.check_connection():
                    return
                
                acct = mt5.account_info()
                if acct:
                    current_equity = float(acct.equity)
                    
                    if current_equity > self.peak_equity:
                        self.peak_equity = current_equity
                    
                    if self.peak_equity > 0:
                        drawdown = (self.peak_equity - current_equity) / self.peak_equity * 100
                        self.max_drawdown = max(self.max_drawdown, drawdown)
                    
                    current_balance = float(acct.balance)
                    profit_pct = ((current_balance - STARTING_BALANCE) / STARTING_BALANCE) * 100.0
                    
                    if profit_pct <= -config.DAILY_LOSS_PCT:
                        self.daily_loss_triggered = True
                        logger.warning(f"Daily loss limit triggered: {profit_pct:.2f}%")
                        logger.log_error("update_daily_stats", 
                                       f"Daily loss limit {profit_pct:.2f}% triggered",
                                       "CRITICAL")
                    
                    if self.max_drawdown >= config.MAX_DRAWDOWN_PCT:
                        self.daily_loss_triggered = True
                        logger.warning(f"Max drawdown limit triggered: {self.max_drawdown:.2f}%")
                        logger.log_error("update_daily_stats",
                                       f"Max drawdown {self.max_drawdown:.2f}% triggered",
                                       "CRITICAL")
                    
            except Exception as e:
                logger.error(f"Error updating daily stats: {e}")
                logger.log_error("update_daily_stats", str(e), "WARNING")
    
    def reset_daily_stats(self):
        with self.lock:
            self.daily_start_date = date.today()
            self.daily_trades_count = 0
            self.daily_loss_triggered = False
            try:
                acct = mt5.account_info()
                if acct:
                    self.peak_equity = float(acct.balance)
            except:
                self.peak_equity = STARTING_BALANCE
            self.max_drawdown = 0.0
            self.session_profits.clear()
            logger.info("Daily stats reset for new trading day")

global_state = EnhancedGlobalState()

# ==================== ENHANCED UTILITY FUNCTIONS ====================
def nowstr():
    return datetime.now().strftime("%Y.%m.%d %H:%M:%S")

def get_bars_enhanced(symbol: str, timeframe: int, n: int = 400) -> pd.DataFrame:
    """Enhanced data fetching with caching and retry"""
    return data_cache.get_data_with_retry(symbol, timeframe, n)

def is_in_no_trade_zone() -> bool:
    t = datetime.now().time()
    if config.NO_TRADE_START <= config.NO_TRADE_END:
        return config.NO_TRADE_START <= t <= config.NO_TRADE_END
    else:
        return t >= config.NO_TRADE_START or t <= config.NO_TRADE_END

def calc_indicators_safe(df: pd.DataFrame) -> pd.DataFrame:
    """Safe indicator calculation with error handling"""
    if df is None or df.empty or len(df) < max(config.EMA_SLOW, config.ATR_PERIOD, config.RSI_PERIOD) + 5:
        return df
    
    df = df.copy()
    
    # Calculate indicators with try-except for each
    indicators_to_calc = [
        ('ema_fast', lambda: EMAIndicator(df['close'], config.EMA_FAST).ema_indicator()),
        ('ema_slow', lambda: EMAIndicator(df['close'], config.EMA_SLOW).ema_indicator()),
        ('atr', lambda: AverageTrueRange(df['high'], df['low'], df['close'], 
                                        config.ATR_PERIOD).average_true_range()),
        ('rsi', lambda: RSIIndicator(df['close'], config.RSI_PERIOD).rsi()),
    ]
    
    for name, calc_func in indicators_to_calc:
        try:
            df[name] = calc_func()
        except Exception as e:
            logger.warning(f"Failed to calculate {name}: {e}")
            logger.log_error("calc_indicators_safe", f"Failed to calculate {name}: {str(e)}", "WARNING")
    
    # Try MACD
    try:
        macd = MACD(df['close'])
        df['macd'] = macd.macd()
        df['macd_signal'] = macd.macd_signal()
        df['macd_diff'] = df['macd'] - df['macd_signal']
    except Exception as e:
        logger.warning(f"Failed to calculate MACD: {e}")
    
    # Try Stochastic
    try:
        st = StochasticOscillator(df['high'], df['low'], df['close'])
        df['stoch_k'] = st.stoch()
        df['stoch_d'] = st.stoch_signal()
    except Exception as e:
        logger.warning(f"Failed to calculate Stochastic: {e}")
    
    # Calculate patterns
    try:
        df['high_10'] = df['high'].rolling(10).max()
        df['low_10'] = df['low'].rolling(10).min()
        
        df['double_top'] = (df['high'].shift(1).round(2) == df['high'].shift(2).round(2)) & (df['close'] < df['high'].shift(1))
        df['double_bottom'] = (df['low'].shift(1).round(2) == df['low'].shift(2).round(2)) & (df['close'] > df['low'].shift(1))
        
        df['engulfing_bull'] = (df['open'].shift(1) > df['close'].shift(1)) & (df['close'] > df['open']) & (df['close'] > df['open'].shift(1)) & (df['open'] < df['close'].shift(1))
        df['engulfing_bear'] = (df['open'].shift(1) < df['close'].shift(1)) & (df['close'] < df['open']) & (df['close'] < df['open'].shift(1)) & (df['open'] > df['close'].shift(1))
        
        body = (df['close'] - df['open']).abs()
        upper = df['high'] - df[['close','open']].max(axis=1)
        lower = df[['close','open']].min(axis=1) - df['low']
        df['pin_bull'] = (lower > body * 2) & (upper < body * 0.5)
        df['pin_bear'] = (upper > body * 2) & (lower < body * 0.5)
        
    except Exception as e:
        logger.warning(f"Failed to calculate patterns: {e}")
        logger.log_error("calc_indicators_safe", f"Pattern calculation failed: {str(e)}", "WARNING")
    
    return df

def detect_market_regime_enhanced(df: pd.DataFrame) -> str:
    """Enhanced market regime detection"""
    if len(df) < config.MARKET_REGIME_PERIOD:
        return "unknown"
    
    try:
        close_prices = df['close'].values[-config.MARKET_REGIME_PERIOD:]
        
        # Calculate linear regression slope
        x = np.arange(len(close_prices))
        slope, _ = np.polyfit(x, close_prices, 1)
        
        # Calculate volatility
        returns = np.diff(np.log(close_prices))
        volatility = np.std(returns) * np.sqrt(252) if len(returns) > 1 else 0
        
        # Calculate ADX-like trend strength
        high = df['high'].values[-config.MARKET_REGIME_PERIOD:]
        low = df['low'].values[-config.MARKET_REGIME_PERIOD:]
        
        tr1 = np.abs(high - low)
        tr2 = np.abs(high - np.roll(close_prices, 1))
        tr3 = np.abs(low - np.roll(close_prices, 1))
        tr = np.maximum.reduce([tr1, tr2, tr3])[1:]
        
        atr = np.mean(tr) if len(tr) > 0 else 0
        
        # Determine regime
        if atr > 0:
            trend_strength = abs(slope) / atr
            if trend_strength > config.TRENDING_THRESHOLD:
                return "trending"
            elif volatility < config.RANGING_THRESHOLD:
                return "ranging"
            else:
                return "volatile"
        else:
            return "unknown"
            
    except Exception as e:
        logger.log_error("detect_market_regime_enhanced", str(e), "WARNING")
        return "unknown"

def active_positions(symbol: str):
    try:
        if not connection_manager.check_connection():
            return []
        
        ps = mt5.positions_get(symbol=symbol)
        if not ps:
            return []
        return [p for p in ps if getattr(p, "magic", None) == config.MAGIC]
    except Exception as e:
        logger.log_error("active_positions", str(e), "WARNING", symbol)
        return []

def latest_our_position(symbol: str):
    try:
        if not connection_manager.check_connection():
            return None
        
        ps = mt5.positions_get(symbol=symbol)
        if not ps:
            return None
        our = [p for p in ps if getattr(p, "magic", None) == config.MAGIC]
        if not our:
            return None
        return sorted(our, key=lambda x: getattr(x, "time_update", 0), reverse=True)[0]
    except Exception as e:
        logger.log_error("latest_our_position", str(e), "WARNING", symbol)
        return None

def symbol_min_stop(symbol: str):
    try:
        if not connection_manager.check_connection():
            return None
        
        info = mt5.symbol_info(symbol)
        if info is None:
            return None
        point = info.point
        level = getattr(info, "trade_stops_level", None)
        if level is None:
            return point * 10
        return max(point * level, point)
    except Exception as e:
        logger.log_error("symbol_min_stop", str(e), "WARNING", symbol)
        return None

def round_lot(symbol: str, lot: float) -> float:
    try:
        if not connection_manager.check_connection():
            return round(lot, 2)
        
        info = mt5.symbol_info(symbol)
        if info is None:
            return round(lot, 2)
        
        min_lot = getattr(info, "volume_min", None) or getattr(info, "min_lot", None) or 0.01
        step = getattr(info, "volume_step", None) or getattr(info, "lot_step", None) or 0.01
        max_lot = getattr(info, "volume_max", None) or getattr(info, "max_lot", None)
        
        if lot < min_lot:
            lot = min_lot
        
        if step > 0:
            steps = int(round((lot - min_lot) / step))
            lot_q = min_lot + steps * step
        else:
            lot_q = lot
        
        if max_lot and lot_q > max_lot:
            lot_q = max_lot
        
        prec = 3 if step < 0.01 else 2
        return round(lot_q, prec)
        
    except Exception as e:
        logger.log_error("round_lot", str(e), "WARNING", symbol)
        return round(lot, 2)

# ==================== GOLD-SPECIFIC ORDER MANAGEMENT ====================
def calculate_gold_stop_loss(symbol: str, entry_price: float, 
                           direction: str, current_atr: float) -> float:
    """Gold-specific stop loss calculation"""
    
    # Get volatility multiplier
    multiplier = volatility_adaptor.get_xau_volatility_multiplier(symbol, current_atr)
    
    # Calculate base stop distance
    sl_distance = current_atr * config.GOLD_SL_MULTIPLIER * multiplier
    
    # Ensure minimum stop for gold
    if "XAUUSD" in symbol:
        min_sl = 1.5  # $1.50 minimum stop for XAUUSD
        if sl_distance < min_sl:
            sl_distance = min_sl
    elif "XAUJPY" in symbol:
        min_sl = 150  # 150 JPY minimum stop for XAUJPY
        if sl_distance < min_sl:
            sl_distance = min_sl
    
    # Calculate stop price
    if direction == 'buy':
        sl_price = entry_price - sl_distance
    else:
        sl_price = entry_price + sl_distance
    
    logger.info(f"{symbol}: Gold SL calculated - ATR: {current_atr:.2f}, Multiplier: {multiplier:.2f}, Distance: {sl_distance:.2f}")
    
    return sl_price

def calculate_gold_take_profit(symbol: str, entry_price: float,
                             direction: str, current_atr: float) -> float:
    """Gold-specific take profit calculation"""
    
    # Get session multiplier
    session_multiplier = SessionFilter.get_session_multiplier(symbol)
    
    # Calculate base TP distance
    tp_distance = current_atr * config.GOLD_TP_MULTIPLIER * session_multiplier
    
    # Ensure minimum TP for gold
    if "XAUUSD" in symbol:
        min_tp = 2.5  # $2.50 minimum TP for XAUUSD
        if tp_distance < min_tp:
            tp_distance = min_tp
    elif "XAUJPY" in symbol:
        min_tp = 250  # 250 JPY minimum TP for XAUJPY
        if tp_distance < min_tp:
            tp_distance = min_tp
    
    # Calculate TP price
    if direction == 'buy':
        tp_price = entry_price + tp_distance
    else:
        tp_price = entry_price - tp_distance
    
    logger.info(f"{symbol}: Gold TP calculated - ATR: {current_atr:.2f}, Multiplier: {session_multiplier:.2f}, Distance: {tp_distance:.2f}")
    
    return tp_price

def market_entry_safe(symbol: str, direction: str, lot: float, comment: str = None):
    """Safe market entry with connection check"""
    try:
        if not connection_manager.check_connection():
            logger.warning(f"{nowstr()} {symbol}: No connection for market entry")
            return None
        
        tick = mt5.symbol_info_tick(symbol)
        if tick is None:
            logger.warning(f"{nowstr()} {symbol}: no tick for market_entry")
            return None
        
        order_type = mt5.ORDER_TYPE_BUY if direction == 'buy' else mt5.ORDER_TYPE_SELL
        price = float(tick.ask) if direction == 'buy' else float(tick.bid)
        
        req = {
            "action": mt5.TRADE_ACTION_DEAL,
            "symbol": symbol,
            "volume": lot,
            "type": order_type,
            "price": price,
            "sl": 0.0,
            "tp": 0.0,
            "deviation": 50,
            "magic": config.MAGIC,
            "comment": (comment or f"{config.MODE}_{direction}")[:31],
            "type_filling": mt5.ORDER_FILLING_IOC
        }
        
        res = mt5.order_send(req)
        
        if res is None:
            logger.error(f"{nowstr()} {symbol}: market_entry returned None mt5.last_error={mt5.last_error()}")
            logger.log_error("market_entry_safe", f"Order send returned None for {symbol}", "ERROR", symbol)
            return None
        
        logger.log_trade({
            'symbol': symbol,
            'direction': direction,
            'entry_price': price,
            'volume': lot,
            'status': 'executed',
            'reason': comment or direction,
            'ticket': res.order if hasattr(res, 'order') else 0,
            'magic': config.MAGIC,
            'consecutive_losses': trade_tracker.consecutive_losses,
            'market_session': SessionFilter.get_current_session()
        })
        
        try:
            if direction == 'buy':
                beep_cash_buy()
            else:
                beep_cash_sell()
            trade_flash(f"{symbol} {direction.upper()} executed via market_entry")
        except Exception:
            pass
        
        return res
        
    except Exception as e:
        logger.error(f"{nowstr()} {symbol}: market_entry_safe exception: {e}")
        logger.log_error("market_entry_safe", str(e), "ERROR", symbol)
        return None

def attach_sl_tp_safe(symbol: str, sl_price: float, tp_price: float, attempt: int = 1):
    """Safe SL/TP attachment with retry"""
    try:
        if not connection_manager.check_connection():
            return None
        
        pos = latest_our_position(symbol)
        if pos is None:
            logger.warning(f"{nowstr()} {symbol}: attach_sl_tp_safe - no our position found")
            return None
        
        ticket = int(pos.ticket)
        req = {
            "action": mt5.TRADE_ACTION_SLTP,
            "position": ticket,
            "symbol": symbol,
            "sl": float(sl_price) if sl_price else 0.0,
            "tp": float(tp_price) if tp_price else 0.0
        }
        
        res = mt5.order_send(req)
        
        if res is None:
            logger.error(f"{nowstr()} {symbol}: attach_sl_tp_safe returned None mt5.last_error={mt5.last_error()}")
            
            if attempt == 1:
                info = mt5.symbol_info(symbol)
                tick = mt5.symbol_info_tick(symbol)
                if info is None or tick is None:
                    return None
                
                min_stop = symbol_min_stop(symbol) or info.point * 10
                
                if pos.type == 0:
                    sl_new = tick.bid - max(min_stop * 2, abs(tick.bid - (sl_price or tick.bid)))
                    tp_new = tick.bid + max(min_stop * 2, abs((tp_price or tick.bid) - tick.bid))
                else:
                    sl_new = tick.ask + max(min_stop * 2, abs((sl_price or tick.ask) - tick.ask))
                    tp_new = tick.ask - max(min_stop * 2, abs(tick.ask - (tp_price or tick.ask)))
                
                logger.info(f"{nowstr()} {symbol}: retry attach_sl_tp_safe with expanded stops")
                return attach_sl_tp_safe(symbol, sl_new, tp_new, attempt=2)
            return None
        
        logger.info(f"{nowstr()} {symbol}: SL/TP attached ticket={ticket} sl={req['sl']} tp={req['tp']}")
        
        # Add to trade tracker
        try:
            direction = 'buy' if pos.type == 0 else 'sell'
            trade_tracker.add_trade(ticket, symbol, direction, 
                                  pos.price_open, sl_price, tp_price)
            logger.info(f"{nowstr()} {symbol}: Trade {ticket} added to tracker")
        except Exception as e:
            logger.error(f"Error adding trade to tracker: {e}")
            logger.log_error("attach_sl_tp_safe", str(e), "WARNING", symbol)
        
        return res
        
    except Exception as e:
        logger.error(f"{nowstr()} {symbol}: attach_sl_tp_safe exception: {e}")
        logger.log_error("attach_sl_tp_safe", str(e), "ERROR", symbol)
        return None

def send_trade_safe(symbol: str, direction: str, lot: float, sl_price: float, tp_price: float, reason: str):
    """Safe trade execution with comprehensive logging"""
    comment = f"{config.MODE}_{direction}_{reason}"[:31]
    
    try:
        if not connection_manager.check_connection():
            logger.warning(f"{nowstr()} {symbol}: No connection for trade")
            return None
        
        tick = mt5.symbol_info_tick(symbol)
        if tick is None:
            logger.warning(f"{nowstr()} {symbol}: no tick in send_trade_safe")
            return None
        
        price = float(tick.ask) if direction == 'buy' else float(tick.bid)
        order_type = mt5.ORDER_TYPE_BUY if direction == 'buy' else mt5.ORDER_TYPE_SELL
        
        request = {
            "action": mt5.TRADE_ACTION_DEAL,
            "symbol": symbol,
            "volume": lot,
            "type": order_type,
            "price": price,
            "sl": float(sl_price) if sl_price else 0.0,
            "tp": float(tp_price) if tp_price else 0.0,
            "deviation": 50,
            "magic": config.MAGIC,
            "comment": comment,
            "type_filling": mt5.ORDER_FILLING_IOC
        }
        
        res = mt5.order_send(request)
        
        if res is None:
            logger.warning(f"{nowstr()} {symbol}: initial order_send returned None -> fallback market_entry")
            entry = market_entry_safe(symbol, direction, lot, comment=comment)
            
            if entry is None:
                logger.error(f"{nowstr()} {symbol}: market entry failed, giving up")
                return None
            
            time.sleep(0.25)
            attach = attach_sl_tp_safe(symbol, sl_price, tp_price)
            
            if attach:
                try:
                    if direction == 'buy':
                        beep_cash_buy()
                    else:
                        beep_cash_sell()
                    trade_flash(f"{symbol} {direction.upper()} executed via fallback! SL={sl_price:.2f} TP={tp_price:.2f}")
                except Exception:
                    pass
            
            return attach
        
        rc = getattr(res, "retcode", None)
        logger.info(f"{nowstr()} {symbol}: order_send returned res.retcode={rc}")
        
        if rc is None or (isinstance(rc, int) and rc != 10009 and rc != 0):
            logger.warning(f"{nowstr()} {symbol}: order_send retcode suggests failure - attempting attach fallback")
            
            entry = market_entry_safe(symbol, direction, lot, comment=comment)
            if entry is None:
                return None
            
            time.sleep(0.25)
            attach = attach_sl_tp_safe(symbol, sl_price, tp_price)
            
            if attach:
                try:
                    if direction == 'buy':
                        beep_cash_buy()
                    else:
                        beep_cash_sell()
                    trade_flash(f"{symbol} {direction.upper()} executed via fallback! SL={sl_price:.2f} TP={tp_price:.2f}")
                except Exception:
                    pass
            
            return attach
        
        try:
            if direction == 'buy':
                beep_cash_buy()
            else:
                beep_cash_sell()
            trade_flash(f"{symbol} {direction.upper()} executed! SL={sl_price:.2f} TP={tp_price:.2f}")
        except Exception:
            pass
        
        # Log the trade
        trade_data = {
            'symbol': symbol,
            'direction': direction.upper(),
            'entry_price': round(price, 3),
            'sl_price': round(sl_price, 3) if sl_price else 0,
            'tp_price': round(tp_price, 3) if tp_price else 0,
            'volume': lot,
            'reason': reason,
            'status': 'executed',
            'ticket': res.order if hasattr(res, 'order') else 0,
            'magic': config.MAGIC,
            'consecutive_losses': trade_tracker.consecutive_losses,
            'market_session': SessionFilter.get_current_session(),
            'trend_alignment': 'confirmed' if enhanced_trend_confirmation(symbol, direction) else 'not_checked'
        }
        
        logger.log_trade(trade_data)
        
        return res
        
    except Exception as e:
        logger.error(f"{nowstr()} {symbol}: ERROR in send_trade_safe: {e}")
        logger.log_error("send_trade_safe", str(e), "ERROR", symbol)
        return None

# ==================== GOLD-SPECIFIC SIGNAL GENERATION ====================
def filter_gold_signals(symbol: str, signals: List[Tuple[str, str, float]]) -> List[Tuple[str, str, float]]:
    """Filter signals specifically for gold trading"""
    
    filtered_signals = []
    
    for direction, signal_type, confidence in signals:
        # Increase confidence requirements for certain signal types
        if signal_type in ["Breakout_Up", "Breakout_Down"]:
            # Breakouts need higher confidence for gold
            confidence = confidence * 1.2
        elif signal_type in ["SR_Bounce_Support", "SR_Bounce_Resistance"]:
            # Support/resistance needs careful confirmation
            confidence = confidence * 0.8
        
        # Check volume confirmation for gold
        df = get_bars_enhanced(symbol, config.ENTRY_TF, 20)
        if not df.empty and 'volume' in df.columns:
            current_volume = df['volume'].iloc[-1]
            avg_volume = df['volume'].rolling(10).mean().iloc[-1] if len(df) >= 10 else current_volume
            
            if current_volume < avg_volume * 0.7:
                # Low volume - reduce confidence
                confidence = confidence * 0.7
                logger.info(f"{symbol}: Low volume warning for {signal_type}")
        
        # Only keep signals with sufficient confidence
        if confidence >= 0.7:
            filtered_signals.append((direction, signal_type, confidence))
    
    return filtered_signals

def detect_patterns_with_confidence(df: pd.DataFrame) -> List[Tuple[str, str, float]]:
    """Detect patterns with confidence scores"""
    if df is None or df.empty:
        return []
    
    last = df.iloc[-1]
    res = []
    
    # Pattern detection with confidence
    patterns = [
        ('double_bottom', 'buy', 'DoubleBottom', 0.7),
        ('double_top', 'sell', 'DoubleTop', 0.7),
        ('engulfing_bull', 'buy', 'EngulfingBull', 0.8),
        ('engulfing_bear', 'sell', 'EngulfingBear', 0.8),
        ('pin_bull', 'buy', 'PinBarBull', 0.75),
        ('pin_bear', 'sell', 'PinBarBear', 0.75)
    ]
    
    for pattern_field, direction, pattern_name, base_confidence in patterns:
        if last.get(pattern_field, False):
            # Adjust confidence based on volume
            volume_confidence = 1.0
            if 'volume' in last:
                avg_volume = df['volume'].rolling(20).mean().iloc[-1]
                if last['volume'] > avg_volume * 1.5:
                    volume_confidence = 1.2
                elif last['volume'] < avg_volume * 0.5:
                    volume_confidence = 0.8
            
            final_confidence = base_confidence * volume_confidence
            res.append((direction, pattern_name, final_confidence))
            
            # Log gold pattern
            logger.log_gold_pattern({
                'timestamp': datetime.now().isoformat(),
                'symbol': 'unknown',  # Will be set by caller
                'pattern_type': pattern_name,
                'direction': direction,
                'success': 'pending',
                'profit': 0,
                'session': SessionFilter.get_current_session(),
                'volatility': float(last.get('atr', 0))
            })
    
    return res

def build_signals_enhanced(symbol: str) -> Tuple[List[Tuple[str, str, float]], pd.DataFrame]:
    """Enhanced signal detection with gold-specific confluence checking"""
    df = calc_indicators_safe(get_bars_enhanced(symbol, config.ENTRY_TF, 400))
    df_htf = calc_indicators_safe(get_bars_enhanced(symbol, config.HTF_TF, 250))
    
    if df.empty or df_htf.empty:
        return [], None
    
    bar = df.iloc[-1]
    bar_htf = df_htf.iloc[-1]
    
    # Get current session
    current_session = SessionFilter.get_current_session()
    
    # Detect market regime
    global_state.market_regimes[symbol] = detect_market_regime_enhanced(df)
    
    signals = []
    signal_strength = 0
    
    # Log debug data
    debug_data = {
        'symbol': symbol,
        'price': float(bar['close']),
        'ema_fast': float(bar.get('ema_fast', 0)),
        'ema_slow': float(bar.get('ema_slow', 0)),
        'rsi': float(bar.get('rsi', 0)),
        'atr': float(bar.get('atr', 0)),
        'market_regime': global_state.market_regimes[symbol],
        'signals_detected': '',
        'volume': float(bar.get('volume', 0)),
        'spread': 0,
        'data_points': len(df),
        'session': current_session,
        'trend_score': 0
    }
    
    try:
        info = mt5.symbol_info(symbol)
        if info:
            debug_data['spread'] = info.spread
    except:
        pass
    
    logger.log_debug(debug_data)
    
    # Check session filter
    if not SessionFilter.should_trade_in_session(symbol):
        logger.info(f"{symbol}: Skipping signal generation - outside optimal session")
        return [], df
    
    # 1. Trend Following Signals (require HTF confirmation)
    if global_state.market_regimes[symbol] == "trending":
        try:
            macd_ok_buy = bar.get('macd', 0) > bar.get('macd_signal', 0)
            macd_ok_sell = bar.get('macd', 0) < bar.get('macd_signal', 0)
            
            # Buy signal with HTF confirmation
            if (bar['ema_fast'] > bar['ema_slow']) and (bar_htf['ema_fast'] > bar_htf['ema_slow']) and macd_ok_buy:
                if bar['close'] > bar['open']:  # Bullish candle
                    signals.append(('buy', 'EMA_Trend_HTF', 0.8))
                    signal_strength += 1
            
            # Sell signal with HTF confirmation
            if (bar['ema_fast'] < bar['ema_slow']) and (bar_htf['ema_fast'] < bar_htf['ema_slow']) and macd_ok_sell:
                if bar['close'] < bar['open']:  # Bearish candle
                    signals.append(('sell', 'EMA_Trend_HTF', 0.8))
                    signal_strength += 1
                    
        except Exception as e:
            logger.warning(f"Trend signal error for {symbol}: {e}")
    
    # 2. Momentum Signals (RSI + Stochastic)
    try:
        rsi_val = float(bar['rsi'])
        stoch_k = float(bar.get('stoch_k', 50))
        stoch_d = float(bar.get('stoch_d', 50))
        
        # Oversold with bullish divergence
        if rsi_val <= config.RSI_OS and stoch_k > stoch_d:
            if bar['close'] > bar['open']:  # Bullish candle
                signals.append(('buy', 'RSI+Stoch_OS', 0.75))
                signal_strength += 1
        
        # Overbought with bearish divergence
        if rsi_val >= config.RSI_OB and stoch_k < stoch_d:
            if bar['close'] < bar['open']:  # Bearish candle
                signals.append(('sell', 'RSI+Stoch_OB', 0.75))
                signal_strength += 1
    except Exception:
       pass
    
    # 3. Support/Resistance Bounce (for ranging markets)
    if global_state.market_regimes[symbol] == "ranging":
        try:
            # Support bounce
            if bar['low'] <= bar['low_10'] and (bar['low_10'] - bar['low']) <= bar['atr']:
                if bar['close'] > bar['open']:  # Bullish reversal
                    signals.append(('buy', 'SR_Bounce_Support', 0.7))
                    signal_strength += 1
            
            # Resistance bounce
            if bar['high'] >= bar['high_10'] and (bar['high'] - bar['high_10']) <= bar['atr']:
                if bar['close'] < bar['open']:  # Bearish reversal
                    signals.append(('sell', 'SR_Bounce_Resistance', 0.7))
                    signal_strength += 1
    except Exception:
       pass
    
    # 4. Breakout Signals (for trending/volatile markets)
    if global_state.market_regimes[symbol] in ["trending", "volatile"]:
        try:
            rh = float(df['high'][-6:-1].max())
            rl = float(df['low'][-6:-1].min())
            current_atr = float(bar['atr'])
            
            # Bullish breakout
            if bar['close'] > rh and (bar['close'] - rh) > (current_atr * 0.2):
                if bar['close'] > bar['open']:  # Bullish candle
                    signals.append(('buy', 'Breakout_Up', 0.8))
                    signal_strength += 1
            
            # Bearish breakout
            if bar['close'] < rl and (rl - bar['close']) > (current_atr * 0.2):
                if bar['close'] < bar['open']:  # Bearish candle
                    signals.append(('sell', 'Breakout_Down', 0.8))
                    signal_strength += 1
    except Exception:
       pass
    
    # 5. Pattern Signals
    patterns = detect_patterns_with_confidence(df)
    for direction, pattern_type, confidence in patterns:
        # Update pattern log with symbol
        logger.log_gold_pattern({
            'timestamp': datetime.now().isoformat(),
            'symbol': symbol,
            'pattern_type': pattern_type,
            'direction': direction,
            'success': 'pending',
            'profit': 0,
            'session': current_session,
            'volatility': float(bar.get('atr', 0))
        })
    
    signals.extend(patterns)
    signal_strength += len(patterns)
    
    # Filter signals for gold
    signals = filter_gold_signals(symbol, signals)
    
    # Update signal strength
    global_state.update_signal_strength(symbol, signal_strength)
    
    # Log all signals
    for direction, signal_type, confidence in signals:
        logger.log_signal({
            'symbol': symbol,
            'signal_direction': direction,
            'signal_type': signal_type,
            'confidence': confidence,
            'price': float(bar['close']),
            'rsi': float(bar.get('rsi', 0)),
            'ema_alignment': 'bullish' if bar.get('ema_fast', 0) > bar.get('ema_slow', 0) else 'bearish',
            'volume_confirmation': bar.get('volume', 0) > df['volume'].rolling(20).mean().iloc[-1] if len(df) >= 20 else False,
            'market_regime': global_state.market_regimes[symbol],
            'confluence_count': signal_strength,
            'action_taken': 'monitoring',
            'session_filter': current_session
        })
    
    # Check ATR minimum
    try:
        atr_value = float(bar['atr'])
        if atr_value < config.GOLD_MIN_ATR and "XAUUSD" in symbol:
            logger.debug(f"{nowstr()} {symbol}: ATR {atr_value:.5f} < GOLD_MIN_ATR {config.GOLD_MIN_ATR:.5f} -> skipping low volatility")
            return [], df
    except Exception:
        pass
    
    return signals, df

# ==================== EXECUTE GOLD TRADE FUNCTION ====================
def execute_gold_trade(symbol: str, direction: str, lot: float, 
                      sl_price: float, tp_price: float, reason: str):
    """Enhanced trade execution with gold-specific logic"""
    
    # Check session filter
    if not SessionFilter.should_trade_in_session(symbol):
        logger.info(f"{symbol}: Skipping trade - outside optimal session")
        return None
    
    # Check trend alignment
    if config.REQUIRE_TREND_ALIGNMENT:
        if not enhanced_trend_confirmation(symbol, direction):
            logger.info(f"{symbol}: Skipping trade - trend not aligned")
            return None
    
    # Check entry timing
    if not smart_entry_timing(symbol, direction):
        logger.info(f"{symbol}: Skipping trade - poor entry timing")
        return None
    
    # Check consecutive losses
    if trade_tracker.consecutive_losses >= config.MAX_CONSECUTIVE_LOSSES:
        if config.LOSS_RECOVERY_MODE:
            lot = lot * config.LOSS_RECOVERY_LOT_MULTIPLIER
            logger.warning(f"{symbol}: Loss recovery mode - reduced lot to {lot:.3f}")
        else:
            logger.warning(f"{symbol}: Max consecutive losses reached - skipping")
            return None
    
    # Check symbol-specific consecutive losses
    if global_state.should_pause_symbol(symbol):
        logger.warning(f"{symbol}: Symbol consecutive loss limit reached - skipping")
        return None
    
    # Execute the trade
    return send_trade_safe(symbol, direction, lot, sl_price, tp_price, reason)

# ==================== ENHANCED HYBRID SL MANAGEMENT ====================
def manage_hybrid_trailing_enhanced(symbol: str):
    """Enhanced trailing stop management with safety checks"""
    if not connection_manager.check_connection():
        return
    
    pos = latest_our_position(symbol)
    if pos is None:
        return
    
    tick = mt5.symbol_info_tick(symbol)
    if tick is None:
        return
    
    # Get current price based on position type
    if pos.type == 0:  # BUY
        current_price = tick.bid
    else:  # SELL
        current_price = tick.ask
    
    # Update trade tracker and get new SL if needed
    ticket = pos.ticket
    result = trade_tracker.update_trade(ticket, current_price)
    
    if result is not None:
        new_sl, move_reason = result
        
        # Get trade info for logging
        trade_info = trade_tracker.get_trade(ticket)
        if trade_info:
            # Calculate TP progress percentage
            entry = trade_info['entry_price']
            tp = trade_info['tp_price']
            direction = trade_info['direction']
            
            if direction == 'buy':
                tp_distance = tp - entry
                current_distance = current_price - entry
            else:
                tp_distance = entry - tp
                current_distance = entry - current_price
            
            tp_progress = current_distance / tp_distance if tp_distance != 0 else 0
            
            # Calculate current profit in USD
            current_profit_usd = trade_tracker.calculate_current_profit_usd(ticket, current_price)
            
            # Get ATR for logging
            atr_value = 0
            try:
                df = get_bars_enhanced(symbol, config.ENTRY_TF, 50)
                if not df.empty:
                    atr_value = float(df.iloc[-1].get('atr', 0))
            except:
                pass
            
            # Update SL
            old_sl = pos.sl
            if old_sl != new_sl:
                try:
                    result = mt5.order_send({
                        "action": mt5.TRADE_ACTION_SLTP,
                        "position": ticket,
                        "sl": new_sl,
                        "tp": pos.tp
                    })
                    
                    if result:
                        logger.info(f"{nowstr()} {symbol}: SL moved from {old_sl:.5f} to {new_sl:.5f} "
                                 f"at {tp_progress*100:.1f}% of TP (${current_profit_usd:.2f} profit) "
                                 f"reason: {move_reason}")
                        
                        # Log SL movement
                        sl_data = {
                            'ticket': ticket,
                            'symbol': symbol,
                            'direction': direction,
                            'entry_price': entry,
                            'current_price': current_price,
                            'old_sl': old_sl,
                            'new_sl': new_sl,
                            'tp_progress_pct': tp_progress,
                            'profit_usd': current_profit_usd,
                            'reason': move_reason,
                            'move_type': 'trailing',
                            'atr_value': atr_value,
                            'session': SessionFilter.get_current_session()
                        }
                        
                        logger.log_sl_movement(sl_data)
                    else:
                        logger.error(f"{nowstr()} {symbol}: Failed to move SL to {new_sl}")
                        logger.log_error("manage_hybrid_trailing_enhanced", 
                                       f"Failed to move SL for ticket {ticket}", 
                                       "ERROR", symbol)
                except Exception as e:
                    logger.error(f"{nowstr()} {symbol}: Error moving SL: {e}")
                    logger.log_error("manage_hybrid_trailing_enhanced", str(e), "ERROR", symbol)
    
    # Check for partial close at 50% of TP
    if config.PARTIAL_CLOSE_ENABLED and pos.tp and pos.tp != 0:
        trade_info = trade_tracker.get_trade(ticket)
        if trade_info and not trade_info.get('partial_closed', False):
            entry = trade_info['entry_price']
            tp = trade_info['tp_price']
            direction = trade_info['direction']
            
            if direction == 'buy':
                tp_distance = tp - entry
                current_distance = current_price - entry
            else:
                tp_distance = entry - tp
                current_distance = entry - current_price
            
            if tp_distance > 0:
                tp_progress = current_distance / tp_distance
                
                if tp_progress >= config.PARTIAL_CLOSE_PCT:
                    try:
                        result = close_partial_position_safe(symbol, pct=config.PARTIAL_CLOSE_PCT)
                        if result:
                            trade_info['partial_closed'] = True
                            logger.info(f"{nowstr()} {symbol}: Partial close executed at {tp_progress*100:.1f}% of TP")
                    except Exception as e:
                        logger.error(f"{nowstr()} {symbol}: Partial close error: {e}")
                        logger.log_error("manage_hybrid_trailing_enhanced", str(e), "WARNING", symbol)

def check_closed_trades_enhanced():
    """Enhanced closed trade checking with learning updates"""
    try:
        if not connection_manager.check_connection():
            return
        
        positions = mt5.positions_get()
        active_tickets = set()
        
        if positions:
            for pos in positions:
                if getattr(pos, "magic", None) == config.MAGIC:
                    active_tickets.add(pos.ticket)
        
        tickets_to_remove = []
        for ticket in list(trade_tracker.trades.keys()):
            if ticket not in active_tickets:
                tickets_to_remove.append(ticket)
        
        # Get history for learning
        for ticket in tickets_to_remove:
            trade_info = trade_tracker.get_trade(ticket)
            if trade_info:
                symbol = trade_info['symbol']
                
                # Get deal info for learning
                deals = mt5.history_deals_get(datetime.now() - timedelta(hours=1), datetime.now())
                if deals:
                    for deal in deals:
                        if getattr(deal, "ticket", 0) == ticket:
                            profit = getattr(deal, "profit", 0.0)
                            comment = getattr(deal, "comment", "")
                            
                            # Extract signal type from comment
                            signal_type = "unknown"
                            parts = comment.split("_")
                            if len(parts) >= 3:
                                signal_type = parts[2]
                            
                            # Update learning stats
                            outcome = "win" if profit > 0 else "loss"
                            global_state.update_learning(symbol, signal_type, outcome, profit)
                            
                            # Update consecutive losses
                            global_state.update_consecutive_losses(symbol, profit)
                            trade_tracker.update_consecutive_losses(profit)
                            
                            logger.info(f"Trade {ticket} closed: ${profit:.2f} ({outcome})")
                            break
            
            trade_tracker.remove_trade(ticket)
            logger.debug(f"Removed closed trade {ticket} from tracker")
            
    except Exception as e:
        logger.error(f"Error in check_closed_trades_enhanced: {e}")
        logger.log_error("check_closed_trades_enhanced", str(e), "ERROR")

# ==================== ENHANCED PERFORMANCE MONITORING ====================
def print_daily_summary_enhanced():
    """Enhanced daily performance summary"""
    try:
        if not connection_manager.check_connection():
            logger.warning("print_daily_summary_enhanced: No connection")
            return
        
        acct = mt5.account_info()
        if acct is None:
            logger.warning("print_daily_summary_enhanced: no account info")
            return
        
        balance = float(acct.balance)
        equity = float(acct.equity) if hasattr(acct, 'equity') else balance
        used = float(acct.margin) if hasattr(acct, 'margin') else 0.0
        free = balance - used
        
        open_positions = mt5.positions_get()
        my_open = []
        if open_positions:
            my_open = [p for p in open_positions if getattr(p, "magic", None) == config.MAGIC]
        
        floating = sum(getattr(p, "profit", 0.0) for p in my_open)
        
        # Get today's deals
        today_start = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
        history = mt5.history_deals_get(today_start, datetime.now())
        win_count = 0
        loss_count = 0
        total_profit = 0
        total_loss = 0
        
        if history:
            for deal in history:
                if getattr(deal, "magic", None) == config.MAGIC:
                    profit = getattr(deal, "profit", 0.0)
                    if profit > 0:
                        win_count += 1
                        total_profit += profit
                    elif profit < 0:
                        loss_count += 1
                        total_loss += abs(profit)
        
        total_trades = win_count + loss_count
        win_rate = (win_count / total_trades * 100) if total_trades > 0 else 0
        profit_factor = (total_profit / total_loss) if total_loss > 0 else float('inf')
        daily_pnl = total_profit - total_loss
        
        # Calculate session profits
        session_profits = global_state.session_profits
        session_summary = ", ".join([f"{k}: ${v:.2f}" for k, v in session_profits.items()])
        
        logger.info("=" * 80)
        logger.info("GOLD-OPTIMIZED DAILY PERFORMANCE SUMMARY")
        logger.info("=" * 80)
        logger.info(f"Balance: ${balance:.2f}")
        logger.info(f"Equity: ${equity:.2f}")
        logger.info(f"Free Margin: ${free:.2f}")
        logger.info(f"Floating P/L: ${floating:.2f}")
        logger.info(f"Open Trades: {len(my_open)}")
        logger.info(f"Daily Trades: {global_state.daily_trades_count}/{config.MAX_DAILY_TRADES}")
        logger.info(f"Win Rate: {win_rate:.1f}% ({win_count}/{total_trades})")
        logger.info(f"Profit Factor: {profit_factor:.2f}")
        logger.info(f"Daily P/L: ${daily_pnl:.2f}")
        logger.info(f"Session Profits: {session_summary}")
        logger.info(f"Max Drawdown: {global_state.max_drawdown:.2f}%")
        logger.info(f"Consecutive Losses: {trade_tracker.consecutive_losses}/{config.CONSECUTIVE_LOSS_LIMIT}")
        logger.info(f"Tracked Trades: {len(trade_tracker.trades)}")
        
        # Show current session
        current_session = SessionFilter.get_current_session()
        logger.info(f"Current Session: {current_session}")
        
        # Show market regimes
        for symbol in config.SYMBOLS:
            regime = global_state.market_regimes.get(symbol, "unknown")
            logger.info(f"{symbol} Regime: {regime}")
        
        logger.info("=" * 80)
        
        # Log performance data
        logger.log_performance({
            'timestamp': datetime.now().isoformat(),
            'date': datetime.now().date().isoformat(),
            'balance': balance,
            'equity': equity,
            'floating_pnl': floating,
            'total_trades': total_trades,
            'win_rate': win_rate,
            'profit_factor': profit_factor,
            'max_drawdown': global_state.max_drawdown,
            'daily_trades': global_state.daily_trades_count,
            'daily_pnl': daily_pnl,
            'consecutive_losses': trade_tracker.consecutive_losses,
            'gold_specific_performance': session_summary,
            'avg_win': total_profit / win_count if win_count > 0 else 0,
            'avg_loss': total_loss / loss_count if loss_count > 0 else 0
        })
        
    except Exception as e:
        logger.error(f"print_daily_summary_enhanced error: {e}")
        logger.log_error("print_daily_summary_enhanced", str(e), "ERROR")

# ==================== QUICK WIN ANALYZER ====================
class QuickWinAnalyzer:
    """Analyze why trades are failing and adjust"""
    
    def __init__(self):
        self.recent_trades = deque(maxlen=20)
        self.patterns = defaultdict(list)
    
    def analyze_trade(self, symbol: str, direction: str, 
                     entry_price: float, exit_price: float,
                     profit: float, reason: str):
        """Analyze trade outcomes to find patterns"""
        
        trade_data = {
            'symbol': symbol,
            'direction': direction,
            'entry_price': entry_price,
            'exit_price': exit_price,
            'profit': profit,
            'reason': reason,
            'timestamp': datetime.now()
        }
        
        self.recent_trades.append(trade_data)
        
        # Analyze losing patterns
        if profit < 0:
            key = f"{symbol}_{direction}_{reason}"
            self.patterns[key].append(profit)
            
            # If we see 2 consecutive losses with same pattern, warn
            if len(self.patterns[key]) >= 2:
                avg_loss = np.mean(self.patterns[key])
                logger.warning(f"⚠️ PATTERN ALERT: {key} - {len(self.patterns[key])} losses, avg: ${avg_loss:.2f}")
                
                # Suggest adjustment
                self.suggest_adjustment(symbol, direction, reason)
    
    def suggest_adjustment(self, symbol: str, direction: str, reason: str):
        """Suggest specific adjustments based on patterns"""
        
        suggestions = {
            "Breakout": "Consider waiting for pullback after breakout",
            "RSI": "Adjust RSI thresholds or wait for divergence",
            "EMA": "Require additional timeframe confirmation",
            "SupportResistance": "Wait for candle close beyond level",
            "Pattern": "Require volume confirmation",
            "Trend": "Check multi-timeframe trend alignment"
        }
        
        for pattern, suggestion in suggestions.items():
            if pattern.lower() in reason.lower():
                logger.info(f"💡 SUGGESTION: {suggestion}")
                break

# Initialize quick win analyzer
quick_win_analyzer = QuickWinAnalyzer()

# ==================== ENHANCED MAIN TRADING LOOP ====================
def trade_symbol_enhanced(symbol: str):
    """Enhanced trading loop for a symbol with gold-specific features"""
    logger.info(f"{nowstr()} Gold-optimized thread started for {symbol}")
    last_bar_time = None
    
    while True:
        try:
            # Check connection
            if not connection_manager.reconnect_if_needed():
                logger.warning(f"{symbol}: Connection issues, waiting...")
                time.sleep(10)
                continue
            
            # Daily reset check
            if date.today() != global_state.daily_start_date:
                global_state.reset_daily_stats()
            
            # Update daily stats
            global_state.update_daily_stats()
            
            # Performance summary
            if time.time() - global_state.last_summary_time > config.SUMMARY_INTERVAL:
                print_daily_summary_enhanced()
                global_state.last_summary_time = time.time()
            
            # Check trading restrictions
            if is_in_no_trade_zone():
                logger.debug(f"{nowstr()} {symbol}: inside no-trade zone; skipping")
                time.sleep(30)
                continue
            
            # Check daily limits
            if global_state.daily_trades_count >= config.MAX_DAILY_TRADES:
                logger.warning(f"{nowstr()} {symbol}: reached MAX_DAILY_TRADES")
                time.sleep(60)
                continue
            
            # Check daily loss/drawdown limits
            if global_state.daily_loss_triggered:
                logger.warning(f"{nowstr()} {symbol}: daily limit triggered - pausing")
                time.sleep(60)
                continue
            
            # Check consecutive losses
            if trade_tracker.should_pause_trading():
                logger.critical(f"{nowstr()} {symbol}: Consecutive loss limit reached - PAUSED")
                time.sleep(60)
                continue
            
            # Check symbol-specific consecutive losses
            if global_state.should_pause_symbol(symbol):
                logger.warning(f"{nowstr()} {symbol}: Symbol consecutive loss limit reached")
                time.sleep(60)
                continue
            
            # Check total positions
            total_positions = 0
            for sym in config.SYMBOLS:
                total_positions += len(active_positions(sym))
            
            if total_positions >= config.MAX_POSITIONS_TOTAL:
                logger.debug(f"{nowstr()} {symbol}: max total positions reached ({total_positions})")
                time.sleep(10)
                continue
            
            # Get signals
            signals, df = build_signals_enhanced(symbol)
            
            if df is None or df.empty:
                time.sleep(1)
                continue
            
            bar = df.iloc[-1]
            
            # Group signals by direction
            buy_signals = [(d, t, c) for d, t, c in signals if d == 'buy']
            sell_signals = [(d, t, c) for d, t, c in signals if d == 'sell']
            
            # Calculate total confidence for each direction
            buy_confidence = sum(c for _, _, c in buy_signals)
            sell_confidence = sum(c for _, _, c in sell_signals)
            
            sigs_text = f"Buy: {len(buy_signals)} (conf: {buy_confidence:.2f}), Sell: {len(sell_signals)} (conf: {sell_confidence:.2f})"
            
            # Log current market state
            try:
                rsi_val = float(bar.get('rsi', math.nan))
                atr_val = float(bar.get('atr', math.nan))
                ema_fast_val = float(bar.get('ema_fast', math.nan))
                ema_slow_val = float(bar.get('ema_slow', math.nan))
            except Exception:
                rsi_val = atr_val = ema_fast_val = ema_slow_val = math.nan
            
            logger.info(f"{nowstr()} {symbol} | Price={bar['close']:.2f} | "
                         f"EMAfast={ema_fast_val:.3f} | EMAslow={ema_slow_val:.3f} | "
                         f"RSI={rsi_val:.2f} | ATR={atr_val:.4f} | "
                         f"Regime={global_state.market_regimes[symbol]} | {sigs_text}")
            
            # Check if new bar
            if last_bar_time is not None and bar['time'] == last_bar_time:
                manage_hybrid_trailing_enhanced(symbol)
                check_closed_trades_enhanced()
                time.sleep(0.2)
                continue
            
            last_bar_time = bar['time']
            
            # Check cooldown
            if time.time() - global_state.last_trade_time.get(symbol, 0) < config.COOLDOWN:
                manage_hybrid_trailing_enhanced(symbol)
                check_closed_trades_enhanced()
                time.sleep(0.2)
                continue
            
            # Determine trade direction based on confluence
            chosen_dir = None
            chosen_reasons = []
            
            # Require minimum confirming signals AND higher confidence threshold for gold
            confidence_threshold = 1.5  # Higher threshold for gold
            
            if len(buy_signals) >= config.MIN_CONFIRMING_SIGNALS and buy_confidence > confidence_threshold:
                chosen_dir = 'buy'
                chosen_reasons = [t for _, t, _ in buy_signals[:2]]
            elif len(sell_signals) >= config.MIN_CONFIRMING_SIGNALS and sell_confidence > confidence_threshold:
                chosen_dir = 'sell'
                chosen_reasons = [t for _, t, _ in sell_signals[:2]]
            
            # Force trade if no signals for a while (but with gold-specific conditions)
            if (chosen_dir is None and 
                time.time() - global_state.last_forced_time.get(symbol, 0) >= config.FORCE_TRADE_EVERY):
                
                # Check if we should force trade in current session
                current_session = SessionFilter.get_current_session()
                if current_session in ["london", "newyork"]:  # Only force in good sessions
                    if bar.get('ema_fast', 0) > bar.get('ema_slow', 0):
                        chosen_dir = 'buy'
                        chosen_reasons = ['FallbackEMA']
                    else:
                        chosen_dir = 'sell'
                        chosen_reasons = ['FallbackEMA']
                    
                    global_state.last_forced_time[symbol] = time.time()
                    logger.info(f"{nowstr()} {symbol}: forced fallback -> {chosen_dir}")
            
            # Check existing positions for this symbol
            opened = active_positions(symbol)
            
            # Execute trade if conditions met
            if (chosen_dir and 
                len(opened) < config.MAX_TRADES_PER_SYMBOL and 
                not global_state.daily_loss_triggered and
                not trade_tracker.should_pause_trading() and
                not global_state.should_pause_symbol(symbol)):
                
                info = mt5.symbol_info(symbol)
                if info is None:
                    time.sleep(0.2)
                    continue
                
                tick = mt5.symbol_info_tick(symbol)
                if tick is None:
                    time.sleep(0.2)
                    continue
                
                entry_price = float(tick.ask) if chosen_dir == 'buy' else float(tick.bid)
                
                # Get gold-specific ATR
                atr = volatility_adaptor.get_gold_specific_atr(symbol, df)
                
                # Check volatility spikes
                if config.AVOID_VOLATILITY_SPIKES:
                    previous_atr = float(df['atr'].iloc[-2]) if len(df) > 1 and 'atr' in df.columns else atr
                    if volatility_adaptor.should_avoid_trading(symbol, atr, previous_atr):
                        logger.warning(f"{symbol}: Avoiding trade due to volatility spike")
                        time.sleep(0.2)
                        continue
                
                # Calculate gold-specific stop loss
                sl_price = calculate_gold_stop_loss(symbol, entry_price, chosen_dir, atr)
                
                # Calculate gold-specific take profit
                tp_price = calculate_gold_take_profit(symbol, entry_price, chosen_dir, atr)
                
                # Ensure minimum stop distance
                min_stop = symbol_min_stop(symbol) or info.point * 10
                if chosen_dir == 'buy' and (entry_price - sl_price) < min_stop:
                    sl_price = entry_price - min_stop
                if chosen_dir == 'sell' and (sl_price - entry_price) < min_stop:
                    sl_price = entry_price + min_stop
                
                # Calculate lot size with loss recovery if needed
                lot = config.LOT_FIXED
                if config.LOSS_RECOVERY_MODE and trade_tracker.consecutive_losses > 0:
                    lot = lot * config.LOSS_RECOVERY_LOT_MULTIPLIER
                    lot = round_lot(symbol, lot)
                    logger.info(f"{symbol}: Loss recovery - lot reduced to {lot:.3f}")
                else:
                    lot = round_lot(symbol, lot)
                
                # Check potential loss
                if chosen_dir == 'buy':
                    potential_loss_points = (entry_price - sl_price) / info.point
                else:
                    potential_loss_points = (sl_price - entry_price) / info.point
                
                # Gold-specific risk calculation
                if "XAUUSD" in symbol:
                    risk_per_point = 0.01  # $0.01 per point for 0.01 lot
                elif "XAUJPY" in symbol:
                    risk_per_point = 0.1  # Adjust for your broker
                else:
                    risk_per_point = 0.01
                
                potential_loss_usd = potential_loss_points * risk_per_point * (lot / 0.01)
                
                if potential_loss_usd > config.MAX_LOSS_PER_TRADE:
                    logger.warning(f"{symbol}: Potential loss ${potential_loss_usd:.2f} > max ${config.MAX_LOSS_PER_TRADE}")
                    # Adjust lot size to respect max loss
                    max_allowed_points = config.MAX_LOSS_PER_TRADE / (risk_per_point * (lot / 0.01))
                    if potential_loss_points > max_allowed_points:
                        adjustment = max_allowed_points / potential_loss_points
                        lot = round_lot(symbol, lot * adjustment)
                        logger.info(f"{symbol}: Adjusted lot to {lot:.3f} due to risk limits")
                
                logger.info(f"{nowstr()} {symbol} ATTEMPT {chosen_dir} lot={lot:.3f} "
                             f"entry={entry_price:.5f} sl={sl_price:.5f} tp={tp_price:.5f} "
                             f"risk_reward={(tp_price-entry_price)/(entry_price-sl_price):.2f} "
                             f"reasons={chosen_reasons} potential_loss=${potential_loss_usd:.2f}")
                
                res = execute_gold_trade(symbol, chosen_dir, lot, sl_price, tp_price, "&".join(chosen_reasons))
                
                if res is None:
                    logger.warning(f"{nowstr()} {symbol}: trade attempt failed. mt5.last_error={mt5.last_error()}")
                else:
                    logger.info(f"{nowstr()} {symbol}: GOLD TRADE EXECUTED ✅ direction={chosen_dir} reasons={chosen_reasons}")
                    
                    try:
                        if chosen_dir == 'buy':
                            beep_cash_buy()
                        else:
                            beep_cash_sell()
                    except Exception:
                        pass
                    
                    global_state.daily_trades_count += 1
                    global_state.last_trade_time[symbol] = time.time()
            
            # Manage existing trades
            manage_hybrid_trailing_enhanced(symbol)
            check_closed_trades_enhanced()
            time.sleep(0.2)
            
        except Exception as e:
            logger.error(f"{nowstr()} {symbol} enhanced loop exception: {e}")
            logger.log_error("trade_symbol_enhanced", str(e), "ERROR", symbol)
            time.sleep(2)

# ==================== AUTOMATIC SUPERVISOR ====================
class AutomatedSupervisor:
    """AUTOMATIC SUPERVISOR: Monitors all bot activities"""
    
    def __init__(self):
        self.running = True
        self.threads_status = {}
        self.last_monitor_time = 0
        self.start_time = time.time()
        self.performance_data = {
            'total_trades': 0,
            'winning_trades': 0,
            'losing_trades': 0,
            'total_profit': 0.0,
            'peak_equity': 0.0,
            'max_drawdown': 0.0
        }
    
    def monitor_all_threads(self):
        """Monitor all running threads"""
        current_time = time.time()
        
        if current_time - self.last_monitor_time < 30:  # Check every 30 seconds
            return
        
        self.last_monitor_time = current_time
        
        # Check connection
        if not connection_manager.check_connection():
            logger.warning("Supervisor: Connection check failed")
            if config.AUTO_RECONNECT:
                connection_manager.reconnect_if_needed()
        
        # Log thread status
        for thread in threading.enumerate():
            if thread.name.startswith("Thread-"):
                if thread.name not in self.threads_status:
                    self.threads_status[thread.name] = {
                        'first_seen': current_time,
                        'last_seen': current_time
                    }
                else:
                    self.threads_status[thread.name]['last_seen'] = current_time
        
        # Check for stalled threads
        for thread_name, status in list(self.threads_status.items()):
            if current_time - status['last_seen'] > 300:  # 5 minutes
                logger.warning(f"Thread {thread_name} appears stalled")
                logger.log_error("monitor_all_threads", 
                               f"Thread {thread_name} stalled", 
                               "WARNING")
        
        # Log performance every 30 minutes
        if current_time - self.start_time > 1800:  # 30 minutes
            self.log_performance_summary()
    
    def log_performance_summary(self):
        """Log comprehensive performance summary"""
        try:
            acct = mt5.account_info()
            if acct:
                equity = float(acct.equity)
                balance = float(acct.balance)
                
                # Update peak equity and drawdown
                if equity > self.performance_data['peak_equity']:
                    self.performance_data['peak_equity'] = equity
                
                if self.performance_data['peak_equity'] > 0:
                    drawdown = (self.performance_data['peak_equity'] - equity) / self.performance_data['peak_equity'] * 100
                    self.performance_data['max_drawdown'] = max(self.performance_data['max_drawdown'], drawdown)
                
                # Get recent trades
                history = mt5.history_deals_get(datetime.now() - timedelta(hours=1), datetime.now())
                if history:
                    for deal in history:
                        if getattr(deal, "magic", None) == config.MAGIC:
                            self.performance_data['total_trades'] += 1
                            profit = getattr(deal, "profit", 0.0)
                            self.performance_data['total_profit'] += profit
                            if profit > 0:
                                self.performance_data['winning_trades'] += 1
                            elif profit < 0:
                                self.performance_data['losing_trades'] += 1
                
                win_rate = (self.performance_data['winning_trades'] / self.performance_data['total_trades'] * 100) \
                          if self.performance_data['total_trades'] > 0 else 0
                
                logger.info("=" * 80)
                logger.info("SUPERVISOR PERFORMANCE REPORT")
                logger.info("=" * 80)
                logger.info(f"Uptime: {timedelta(seconds=int(current_time - self.start_time))}")
                logger.info(f"Active Threads: {threading.active_count()}")
                logger.info(f"Balance: ${balance:.2f} | Equity: ${equity:.2f}")
                logger.info(f"Total Trades: {self.performance_data['total_trades']}")
                logger.info(f"Win Rate: {win_rate:.1f}%")
                logger.info(f"Total Profit: ${self.performance_data['total_profit']:.2f}")
                logger.info(f"Max Drawdown: {self.performance_data['max_drawdown']:.2f}%")
                logger.info(f"Consecutive Losses: {trade_tracker.consecutive_losses}")
                logger.info(f"Tracked Trades: {len(trade_tracker.trades)}")
                logger.info(f"Current Session: {SessionFilter.get_current_session()}")
                logger.info("=" * 80)
                
        except Exception as e:
            logger.error(f"Error in performance summary: {e}")
            logger.log_error("log_performance_summary", str(e), "WARNING")
    
    def run(self):
        """Main supervisor loop"""
        logger.info("Supervisor thread started")
        
        while self.running:
            try:
                self.monitor_all_threads()
                time.sleep(5)  # Check every 5 seconds
            except Exception as e:
                logger.error(f"Supervisor error: {e}")
                logger.log_error("supervisor_run", str(e), "ERROR")
                time.sleep(10)

# ==================== ENHANCED MAIN EXECUTION ====================
def main_enhanced():
    """Enhanced main execution with gold-specific optimizations"""
    try:
        logger.info("=" * 80)
        logger.info("GOLD-OPTIMIZED XAU BOT - PROFESSIONAL EDITION v17")
        logger.info("SPECIFICALLY TUNED FOR GOLD VOLATILITY PATTERNS")
        logger.info("=" * 80)
        logger.info(f"Run ID: {logger.run_timestamp}")
        logger.info(f"Log Directory: {logger.log_dir}")
        logger.info(f"Starting with symbols: {config.SYMBOLS}")
        logger.info(f"Starting balance: ${STARTING_BALANCE:.2f}")
        logger.info("=" * 80)
        logger.info("GOLD-SPECIFIC OPTIMIZATIONS:")
        logger.info(f"  • Wider stops: SL {config.GOLD_SL_MULTIPLIER}x ATR")
        logger.info(f"  • Better risk/reward: TP {config.GOLD_TP_MULTIPLIER}x ATR")
        logger.info(f"  • Session filtering: Asian={config.TRADE_ASIAN_SESSION}, London={config.TRADE_LONDON_SESSION}, NY={config.TRADE_NY_SESSION}")
        logger.info(f"  • Trend alignment: Require {config.MIN_TREND_TIMEFRAMES} timeframe confirmation")
        logger.info(f"  • Loss recovery: {config.LOSS_RECOVERY_MODE} (multiplier: {config.LOSS_RECOVERY_LOT_MULTIPLIER})")
        logger.info(f"  • Max consecutive losses: {config.MAX_CONSECUTIVE_LOSSES} before pause")
        logger.info("=" * 80)
        logger.info("AUTOMATION FEATURES:")
        logger.info("  ✅ Gold volatility adaptation")
        logger.info("  ✅ Session-based trading optimization")
        logger.info("  ✅ Multi-timeframe trend confirmation")
        logger.info("  ✅ Smart entry timing to avoid false breakouts")
        logger.info("  ✅ Loss recovery with reduced position sizing")
        logger.info("  ✅ Comprehensive gold pattern analysis")
        logger.info("=" * 80)
        
        # Start supervisor
        supervisor = AutomatedSupervisor()
        supervisor_thread = threading.Thread(target=supervisor.run, name="Supervisor", daemon=True)
        supervisor_thread.start()
        logger.info("Supervisor thread started")
        
        # Start trading threads
        threads = []
        for symbol in config.SYMBOLS:
            t = threading.Thread(target=trade_symbol_enhanced, args=(symbol,), 
                               name=f"Gold_Trader_{symbol}", daemon=True)
            t.start()
            threads.append(t)
            time.sleep(0.5)
            logger.info(f"Gold-optimized trading thread started for {symbol}")
        
        logger.info("✅ GOLD-OPTIMIZED BOT INITIALIZED AND RUNNING")
        logger.info("=" * 80)
        
        # Main monitoring loop
        while True:
            try:
                # Check connection
                if not connection_manager.reconnect_if_needed():
                    logger.warning("Main loop: Connection issues detected")
                    time.sleep(10)
                    continue
                
                # Performance summary
                if time.time() - global_state.last_summary_time > config.SUMMARY_INTERVAL:
                    print_daily_summary_enhanced()
                    global_state.last_summary_time = time.time()
                
                # Log session status
                current_session = SessionFilter.get_current_session()
                logger.debug(f"Current session: {current_session}")
                
                time.sleep(10)
                
            except KeyboardInterrupt:
                logger.info("Bot stopped by user (KeyboardInterrupt)")
                break
            except Exception as e:
                logger.error(f"Main supervisor loop exception: {e}")
                logger.log_error("main_enhanced", str(e), "CRITICAL")
                time.sleep(5)
                
    except KeyboardInterrupt:
        logger.info("Bot stopped by user (KeyboardInterrupt)")
    except Exception as e:
        logger.critical(f"Critical error in main_enhanced: {e}")
        logger.log_error("main_enhanced", str(e), "CRITICAL")
    finally:
        try:
            logger.info("Shutting down bot...")
            logger.info("=" * 80)
            logger.info("FINAL GOLD TRADING SUMMARY")
            logger.info("=" * 80)
            print_daily_summary_enhanced()
            
            # Log final session profits
            logger.info("Session Profit Summary:")
            for session, profit in global_state.session_profits.items():
                logger.info(f"  {session}: ${profit:.2f}")
            
            logger.info(f"All logs saved to: {logger.log_dir}")
            logger.info("Shutting down MT5...")
            mt5.shutdown()
            logger.info("MT5 shutdown complete")
            logger.info("=" * 80)
        except Exception as e:
            logger.error(f"Shutdown error: {e}")

if __name__ == "__main__":
    main_enhanced()
